{
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/BNilInstr.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/BFalseInstr.java",
                "SLOC": "32",
                "content": "package org.jruby.ir.instructions;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.operands.Label;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.persistence.IRReaderDecoder;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\nimport org.jruby.parser.StaticScope;\nimport org.jruby.runtime.DynamicScope;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\n\npublic class BFalseInstr extends OneOperandBranchInstr implements FixedArityInstr {\n    public BFalseInstr(Label jmpTarget, Operand v) {\n        super(Operation.B_FALSE, jmpTarget, v);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return new BFalseInstr(ii.getRenamedLabel(getJumpTarget()), getArg1().cloneForInlining(ii));\n    }\n\n    public static BFalseInstr decode(IRReaderDecoder d) {\n        return new BFalseInstr(d.decodeLabel(), d.decodeOperand());\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.BFalseInstr(this);\n    }\n\n    @Override\n    public int interpretAndGetNewIPC(ThreadContext context, DynamicScope currDynScope, StaticScope currScope, IRubyObject self, Object[] temp, int ipc) {\n        Object value1 = getArg1().retrieve(context, self, currScope, currDynScope, temp);\n        return !((IRubyObject)value1).isTrue() ? getJumpTarget().getTargetPC() : ipc;\n    }\n}\n"
            }
        ],
        "SLOC": "32",
        "content": "package org.jruby.ir.instructions;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.operands.Label;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.persistence.IRReaderDecoder;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\nimport org.jruby.parser.StaticScope;\nimport org.jruby.runtime.DynamicScope;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\n\npublic class BNilInstr extends OneOperandBranchInstr  implements FixedArityInstr {\n    public BNilInstr(Label jmpTarget, Operand v) {\n        super(Operation.B_NIL, jmpTarget, v);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return new BNilInstr(ii.getRenamedLabel(getJumpTarget()), getArg1().cloneForInlining(ii));\n    }\n\n    public static BNilInstr decode(IRReaderDecoder d) {\n        return new BNilInstr(d.decodeLabel(), d.decodeOperand());\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.BNilInstr(this);\n    }\n\n    @Override\n    public int interpretAndGetNewIPC(ThreadContext context, DynamicScope currDynScope, StaticScope currScope, IRubyObject self, Object[] temp, int ipc) {\n        Object value1 = getArg1().retrieve(context, self, currScope, currDynScope, temp);\n        return value1 == context.nil ? getJumpTarget().getTargetPC() : ipc;\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/BTrueInstr.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/BNilInstr.java",
                "SLOC": "32",
                "content": "package org.jruby.ir.instructions;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.operands.Label;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.persistence.IRReaderDecoder;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\nimport org.jruby.parser.StaticScope;\nimport org.jruby.runtime.DynamicScope;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\n\npublic class BNilInstr extends OneOperandBranchInstr  implements FixedArityInstr {\n    public BNilInstr(Label jmpTarget, Operand v) {\n        super(Operation.B_NIL, jmpTarget, v);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return new BNilInstr(ii.getRenamedLabel(getJumpTarget()), getArg1().cloneForInlining(ii));\n    }\n\n    public static BNilInstr decode(IRReaderDecoder d) {\n        return new BNilInstr(d.decodeLabel(), d.decodeOperand());\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.BNilInstr(this);\n    }\n\n    @Override\n    public int interpretAndGetNewIPC(ThreadContext context, DynamicScope currDynScope, StaticScope currScope, IRubyObject self, Object[] temp, int ipc) {\n        Object value1 = getArg1().retrieve(context, self, currScope, currDynScope, temp);\n        return value1 == context.nil ? getJumpTarget().getTargetPC() : ipc;\n    }\n}\n"
            }
        ],
        "SLOC": "32",
        "content": "package org.jruby.ir.instructions;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.operands.Label;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.persistence.IRReaderDecoder;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\nimport org.jruby.parser.StaticScope;\nimport org.jruby.runtime.DynamicScope;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\n\npublic class BTrueInstr extends OneOperandBranchInstr implements FixedArityInstr {\n    public BTrueInstr(Label jmpTarget, Operand v) {\n        super(Operation.B_TRUE, jmpTarget, v);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return new BTrueInstr(ii.getRenamedLabel(getJumpTarget()), getArg1().cloneForInlining(ii));\n    }\n\n    public static BTrueInstr decode(IRReaderDecoder d) {\n        return new BTrueInstr(d.decodeLabel(), d.decodeOperand());\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.BTrueInstr(this);\n    }\n\n    @Override\n    public int interpretAndGetNewIPC(ThreadContext context, DynamicScope currDynScope, StaticScope currScope, IRubyObject self, Object[] temp, int ipc) {\n        Object value1 = getArg1().retrieve(context, self, currScope, currDynScope, temp);\n        return ((IRubyObject)value1).isTrue() ? getJumpTarget().getTargetPC() : ipc;\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/BUndefInstr.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/BFalseInstr.java",
                "SLOC": "32",
                "content": "package org.jruby.ir.instructions;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.operands.Label;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.persistence.IRReaderDecoder;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\nimport org.jruby.parser.StaticScope;\nimport org.jruby.runtime.DynamicScope;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\n\npublic class BFalseInstr extends OneOperandBranchInstr implements FixedArityInstr {\n    public BFalseInstr(Label jmpTarget, Operand v) {\n        super(Operation.B_FALSE, jmpTarget, v);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return new BFalseInstr(ii.getRenamedLabel(getJumpTarget()), getArg1().cloneForInlining(ii));\n    }\n\n    public static BFalseInstr decode(IRReaderDecoder d) {\n        return new BFalseInstr(d.decodeLabel(), d.decodeOperand());\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.BFalseInstr(this);\n    }\n\n    @Override\n    public int interpretAndGetNewIPC(ThreadContext context, DynamicScope currDynScope, StaticScope currScope, IRubyObject self, Object[] temp, int ipc) {\n        Object value1 = getArg1().retrieve(context, self, currScope, currDynScope, temp);\n        return !((IRubyObject)value1).isTrue() ? getJumpTarget().getTargetPC() : ipc;\n    }\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/BNilInstr.java",
                "SLOC": "32",
                "content": "package org.jruby.ir.instructions;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.operands.Label;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.persistence.IRReaderDecoder;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\nimport org.jruby.parser.StaticScope;\nimport org.jruby.runtime.DynamicScope;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\n\npublic class BNilInstr extends OneOperandBranchInstr  implements FixedArityInstr {\n    public BNilInstr(Label jmpTarget, Operand v) {\n        super(Operation.B_NIL, jmpTarget, v);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return new BNilInstr(ii.getRenamedLabel(getJumpTarget()), getArg1().cloneForInlining(ii));\n    }\n\n    public static BNilInstr decode(IRReaderDecoder d) {\n        return new BNilInstr(d.decodeLabel(), d.decodeOperand());\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.BNilInstr(this);\n    }\n\n    @Override\n    public int interpretAndGetNewIPC(ThreadContext context, DynamicScope currDynScope, StaticScope currScope, IRubyObject self, Object[] temp, int ipc) {\n        Object value1 = getArg1().retrieve(context, self, currScope, currDynScope, temp);\n        return value1 == context.nil ? getJumpTarget().getTargetPC() : ipc;\n    }\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/BTrueInstr.java",
                "SLOC": "32",
                "content": "package org.jruby.ir.instructions;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.operands.Label;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.persistence.IRReaderDecoder;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\nimport org.jruby.parser.StaticScope;\nimport org.jruby.runtime.DynamicScope;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\n\npublic class BTrueInstr extends OneOperandBranchInstr implements FixedArityInstr {\n    public BTrueInstr(Label jmpTarget, Operand v) {\n        super(Operation.B_TRUE, jmpTarget, v);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return new BTrueInstr(ii.getRenamedLabel(getJumpTarget()), getArg1().cloneForInlining(ii));\n    }\n\n    public static BTrueInstr decode(IRReaderDecoder d) {\n        return new BTrueInstr(d.decodeLabel(), d.decodeOperand());\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.BTrueInstr(this);\n    }\n\n    @Override\n    public int interpretAndGetNewIPC(ThreadContext context, DynamicScope currDynScope, StaticScope currScope, IRubyObject self, Object[] temp, int ipc) {\n        Object value1 = getArg1().retrieve(context, self, currScope, currDynScope, temp);\n        return ((IRubyObject)value1).isTrue() ? getJumpTarget().getTargetPC() : ipc;\n    }\n}\n"
            }
        ],
        "SLOC": "33",
        "content": "package org.jruby.ir.instructions;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.operands.Label;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.operands.UndefinedValue;\nimport org.jruby.ir.persistence.IRReaderDecoder;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\nimport org.jruby.parser.StaticScope;\nimport org.jruby.runtime.DynamicScope;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\n\npublic class BUndefInstr extends OneOperandBranchInstr  implements FixedArityInstr {\n    public BUndefInstr(Label jmpTarget, Operand v) {\n        super(Operation.B_UNDEF, jmpTarget, v);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return new BUndefInstr(ii.getRenamedLabel(getJumpTarget()), getArg1().cloneForInlining(ii));\n    }\n\n    public static BUndefInstr decode(IRReaderDecoder d) {\n        return new BUndefInstr(d.decodeLabel(), d.decodeOperand());\n    }\n\n    @Override\n    public int interpretAndGetNewIPC(ThreadContext context, DynamicScope currDynScope, StaticScope currScope, IRubyObject self, Object[] temp, int ipc) {\n        Object value1 = getArg1().retrieve(context, self, currScope, currDynScope, temp);\n        return value1 == UndefinedValue.UNDEFINED ? getJumpTarget().getTargetPC() : ipc;\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.BUndefInstr(this);\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/PopMethodFrameInstr.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/PopBackrefFrameInstr.java",
                "SLOC": "22",
                "content": "package org.jruby.ir.instructions;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.persistence.IRReaderDecoder;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\nimport org.jruby.ir.transformations.inlining.SimpleCloneInfo;\n\npublic class PopBackrefFrameInstr extends NoOperandInstr implements FixedArityInstr {\n    public PopBackrefFrameInstr() {\n        super(Operation.POP_BACKREF_FRAME);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return ii instanceof SimpleCloneInfo ? this : NopInstr.NOP;  // FIXME: Is this correct\n    }\n\n    public static PopBackrefFrameInstr decode(IRReaderDecoder d) {\n        return new PopBackrefFrameInstr();\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.PopBackrefFrameInstr(this);\n    }\n}\n"
            }
        ],
        "SLOC": "22",
        "content": "package org.jruby.ir.instructions;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.persistence.IRReaderDecoder;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\nimport org.jruby.ir.transformations.inlining.SimpleCloneInfo;\n\npublic class PopMethodFrameInstr extends NoOperandInstr implements FixedArityInstr {\n    public PopMethodFrameInstr() {\n        super(Operation.POP_METHOD_FRAME);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return ii instanceof SimpleCloneInfo ? this : NopInstr.NOP;  // FIXME: Is this correct\n    }\n\n    public static PopMethodFrameInstr decode(IRReaderDecoder d) {\n        return new PopMethodFrameInstr();\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.PopMethodFrameInstr(this);\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/PrepareNoBlockArgsInstr.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/PrepareFixedBlockArgsInstr.java",
                "SLOC": "23",
                "content": "package org.jruby.ir.instructions;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.persistence.IRReaderDecoder;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\nimport org.jruby.ir.transformations.inlining.SimpleCloneInfo;\n\npublic class PrepareFixedBlockArgsInstr extends PrepareBlockArgsInstr  {\n    public static final PrepareFixedBlockArgsInstr INSTANCE = new PrepareFixedBlockArgsInstr();\n\n    private PrepareFixedBlockArgsInstr() {\n        super(Operation.PREPARE_FIXED_BLOCK_ARGS);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return ii instanceof SimpleCloneInfo ? new PrepareFixedBlockArgsInstr() : NopInstr.NOP;  // FIXME: Is this correct\n    }\n\n    public static PrepareFixedBlockArgsInstr decode(IRReaderDecoder d) {\n        return INSTANCE;\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.PrepareFixedBlockArgsInstr(this);\n    }\n}\n"
            }
        ],
        "SLOC": "23",
        "content": "package org.jruby.ir.instructions;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.persistence.IRReaderDecoder;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\nimport org.jruby.ir.transformations.inlining.SimpleCloneInfo;\n\npublic class PrepareNoBlockArgsInstr extends PrepareBlockArgsInstr  {\n    public static final PrepareNoBlockArgsInstr INSTANCE = new PrepareNoBlockArgsInstr();\n\n    private PrepareNoBlockArgsInstr() {\n        super(Operation.PREPARE_NO_BLOCK_ARGS);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return ii instanceof SimpleCloneInfo ? new PrepareNoBlockArgsInstr() : NopInstr.NOP;  // FIXME: Is this correct\n    }\n\n    public static PrepareNoBlockArgsInstr decode(IRReaderDecoder d) {\n        return INSTANCE;\n    }\n    \n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.PrepareNoBlockArgsInstr(this);\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/PrepareSingleBlockArgInstr.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/PrepareFixedBlockArgsInstr.java",
                "SLOC": "23",
                "content": "package org.jruby.ir.instructions;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.persistence.IRReaderDecoder;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\nimport org.jruby.ir.transformations.inlining.SimpleCloneInfo;\n\npublic class PrepareFixedBlockArgsInstr extends PrepareBlockArgsInstr  {\n    public static final PrepareFixedBlockArgsInstr INSTANCE = new PrepareFixedBlockArgsInstr();\n\n    private PrepareFixedBlockArgsInstr() {\n        super(Operation.PREPARE_FIXED_BLOCK_ARGS);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return ii instanceof SimpleCloneInfo ? new PrepareFixedBlockArgsInstr() : NopInstr.NOP;  // FIXME: Is this correct\n    }\n\n    public static PrepareFixedBlockArgsInstr decode(IRReaderDecoder d) {\n        return INSTANCE;\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.PrepareFixedBlockArgsInstr(this);\n    }\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/PrepareNoBlockArgsInstr.java",
                "SLOC": "23",
                "content": "package org.jruby.ir.instructions;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.persistence.IRReaderDecoder;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\nimport org.jruby.ir.transformations.inlining.SimpleCloneInfo;\n\npublic class PrepareNoBlockArgsInstr extends PrepareBlockArgsInstr  {\n    public static final PrepareNoBlockArgsInstr INSTANCE = new PrepareNoBlockArgsInstr();\n\n    private PrepareNoBlockArgsInstr() {\n        super(Operation.PREPARE_NO_BLOCK_ARGS);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return ii instanceof SimpleCloneInfo ? new PrepareNoBlockArgsInstr() : NopInstr.NOP;  // FIXME: Is this correct\n    }\n\n    public static PrepareNoBlockArgsInstr decode(IRReaderDecoder d) {\n        return INSTANCE;\n    }\n    \n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.PrepareNoBlockArgsInstr(this);\n    }\n}\n"
            }
        ],
        "SLOC": "23",
        "content": "package org.jruby.ir.instructions;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.persistence.IRReaderDecoder;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\nimport org.jruby.ir.transformations.inlining.SimpleCloneInfo;\n\npublic class PrepareSingleBlockArgInstr extends PrepareBlockArgsInstr  {\n    public static final PrepareSingleBlockArgInstr INSTANCE = new PrepareSingleBlockArgInstr();\n\n    private PrepareSingleBlockArgInstr() {\n        super(Operation.PREPARE_SINGLE_BLOCK_ARG);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return ii instanceof SimpleCloneInfo ? new PrepareSingleBlockArgInstr() : NopInstr.NOP;  // FIXME: Is this correct\n    }\n\n    public static PrepareSingleBlockArgInstr decode(IRReaderDecoder d) {\n        return INSTANCE;\n    }\n    \n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.PrepareSingleBlockArgInstr(this);\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/PushBackrefFrameInstr.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/PopBackrefFrameInstr.java",
                "SLOC": "22",
                "content": "package org.jruby.ir.instructions;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.persistence.IRReaderDecoder;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\nimport org.jruby.ir.transformations.inlining.SimpleCloneInfo;\n\npublic class PopBackrefFrameInstr extends NoOperandInstr implements FixedArityInstr {\n    public PopBackrefFrameInstr() {\n        super(Operation.POP_BACKREF_FRAME);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return ii instanceof SimpleCloneInfo ? this : NopInstr.NOP;  // FIXME: Is this correct\n    }\n\n    public static PopBackrefFrameInstr decode(IRReaderDecoder d) {\n        return new PopBackrefFrameInstr();\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.PopBackrefFrameInstr(this);\n    }\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/PopMethodFrameInstr.java",
                "SLOC": "22",
                "content": "package org.jruby.ir.instructions;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.persistence.IRReaderDecoder;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\nimport org.jruby.ir.transformations.inlining.SimpleCloneInfo;\n\npublic class PopMethodFrameInstr extends NoOperandInstr implements FixedArityInstr {\n    public PopMethodFrameInstr() {\n        super(Operation.POP_METHOD_FRAME);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return ii instanceof SimpleCloneInfo ? this : NopInstr.NOP;  // FIXME: Is this correct\n    }\n\n    public static PopMethodFrameInstr decode(IRReaderDecoder d) {\n        return new PopMethodFrameInstr();\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.PopMethodFrameInstr(this);\n    }\n}\n"
            }
        ],
        "SLOC": "22",
        "content": "package org.jruby.ir.instructions;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.persistence.IRReaderDecoder;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\nimport org.jruby.ir.transformations.inlining.SimpleCloneInfo;\n\npublic class PushBackrefFrameInstr extends NoOperandInstr implements FixedArityInstr {\n    public PushBackrefFrameInstr() {\n        super(Operation.PUSH_BACKREF_FRAME);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return ii instanceof SimpleCloneInfo ? this : NopInstr.NOP;  // FIXME: Is this correct?\n    }\n\n    public static PushBackrefFrameInstr decode(IRReaderDecoder d) {\n        return new PushBackrefFrameInstr();\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.PushBackrefFrameInstr(this);\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/PushMethodBindingInstr.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/PushBlockBindingInstr.java",
                "SLOC": "21",
                "content": "package org.jruby.ir.instructions;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.persistence.IRReaderDecoder;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\n\npublic class PushBlockBindingInstr extends NoOperandInstr implements FixedArityInstr {\n    public PushBlockBindingInstr() {\n        super(Operation.PUSH_BLOCK_BINDING);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return this; // FIXME: This has to be wrong if pop_binding is conditionally noop'ing on inline\n    }\n\n    public static PushBlockBindingInstr decode(IRReaderDecoder d) {\n        return new PushBlockBindingInstr();\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.PushBlockBindingInstr(this);\n    }\n}\n"
            }
        ],
        "SLOC": "21",
        "content": "package org.jruby.ir.instructions;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.persistence.IRReaderDecoder;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\n\npublic class PushMethodBindingInstr extends NoOperandInstr implements FixedArityInstr {\n    public PushMethodBindingInstr() {\n        super(Operation.PUSH_METHOD_BINDING);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return this; // FIXME: This has to be wrong if pop_binding is conditionally noop'ing on inline\n    }\n\n    public static PushMethodBindingInstr decode(IRReaderDecoder d) {\n        return new PushMethodBindingInstr();\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.PushMethodBindingInstr(this);\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/ReceiveRubyExceptionInstr.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/ReceiveJRubyExceptionInstr.java",
                "SLOC": "22",
                "content": "package org.jruby.ir.instructions;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.operands.Variable;\nimport org.jruby.ir.persistence.IRReaderDecoder;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\n\npublic class ReceiveJRubyExceptionInstr extends ReceiveExceptionBase {\n    public ReceiveJRubyExceptionInstr(Variable result) {\n        super(Operation.RECV_JRUBY_EXC, result);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return new ReceiveJRubyExceptionInstr(ii.getRenamedVariable(result));\n    }\n\n    public static ReceiveJRubyExceptionInstr decode(IRReaderDecoder d) {\n        return new ReceiveJRubyExceptionInstr(d.decodeVariable());\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.ReceiveJRubyExceptionInstr(this);\n    }\n}\n"
            }
        ],
        "SLOC": "22",
        "content": "package org.jruby.ir.instructions;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.operands.Variable;\nimport org.jruby.ir.persistence.IRReaderDecoder;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\n\npublic class ReceiveRubyExceptionInstr extends ReceiveExceptionBase {\n    public ReceiveRubyExceptionInstr(Variable result) {\n        super(Operation.RECV_RUBY_EXC, result);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return new ReceiveRubyExceptionInstr(ii.getRenamedVariable(result));\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.ReceiveRubyExceptionInstr(this);\n    }\n\n    public static ReceiveRubyExceptionInstr decode(IRReaderDecoder d) {\n        return new ReceiveRubyExceptionInstr(d.decodeVariable());\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/RestoreBindingVisibilityInstr.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/PopBlockFrameInstr.java",
                "SLOC": "32",
                "content": "package org.jruby.ir.instructions;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.persistence.IRReaderDecoder;\nimport org.jruby.ir.persistence.IRWriterEncoder;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\nimport org.jruby.ir.transformations.inlining.SimpleCloneInfo;\n\npublic class PopBlockFrameInstr extends OneOperandInstr implements FixedArityInstr {\n    public PopBlockFrameInstr(Operand frame) {\n        super(Operation.POP_BLOCK_FRAME, frame);\n    }\n\n    public Operand getFrame() {\n        return getOperand1();\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return ii instanceof SimpleCloneInfo ? this : NopInstr.NOP;  // FIXME: Is this correct\n    }\n\n    @Override\n    public void encode(IRWriterEncoder e) {\n        super.encode(e);\n        e.encode(getFrame());\n    }\n\n    public static PopBlockFrameInstr decode(IRReaderDecoder d) {\n        return new PopBlockFrameInstr(d.decodeOperand());\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.PopBlockFrameInstr(this);\n    }\n}\n"
            }
        ],
        "SLOC": "32",
        "content": "package org.jruby.ir.instructions;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.persistence.IRReaderDecoder;\nimport org.jruby.ir.persistence.IRWriterEncoder;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\nimport org.jruby.ir.transformations.inlining.SimpleCloneInfo;\n\npublic class RestoreBindingVisibilityInstr extends OneOperandInstr implements FixedArityInstr {\n    public RestoreBindingVisibilityInstr(Operand viz) {\n        super(Operation.RESTORE_BINDING_VIZ, viz);\n    }\n\n    public Operand getVisibility() {\n        return getOperand1();\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return ii instanceof SimpleCloneInfo ? this : NopInstr.NOP;  // FIXME: Is this correct?\n    }\n\n    public static RestoreBindingVisibilityInstr decode(IRReaderDecoder d) {\n        return new RestoreBindingVisibilityInstr(d.decodeVariable());\n    }\n\n    @Override\n    public void encode(IRWriterEncoder e) {\n        super.encode(e);\n        e.encode(getVisibility());\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.RestoreBindingVisibilityInstr(this);\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/UpdateBlockExecutionStateInstr.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/PopBlockFrameInstr.java",
                "SLOC": "32",
                "content": "package org.jruby.ir.instructions;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.persistence.IRReaderDecoder;\nimport org.jruby.ir.persistence.IRWriterEncoder;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\nimport org.jruby.ir.transformations.inlining.SimpleCloneInfo;\n\npublic class PopBlockFrameInstr extends OneOperandInstr implements FixedArityInstr {\n    public PopBlockFrameInstr(Operand frame) {\n        super(Operation.POP_BLOCK_FRAME, frame);\n    }\n\n    public Operand getFrame() {\n        return getOperand1();\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return ii instanceof SimpleCloneInfo ? this : NopInstr.NOP;  // FIXME: Is this correct\n    }\n\n    @Override\n    public void encode(IRWriterEncoder e) {\n        super.encode(e);\n        e.encode(getFrame());\n    }\n\n    public static PopBlockFrameInstr decode(IRReaderDecoder d) {\n        return new PopBlockFrameInstr(d.decodeOperand());\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.PopBlockFrameInstr(this);\n    }\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/RestoreBindingVisibilityInstr.java",
                "SLOC": "32",
                "content": "package org.jruby.ir.instructions;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.persistence.IRReaderDecoder;\nimport org.jruby.ir.persistence.IRWriterEncoder;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\nimport org.jruby.ir.transformations.inlining.SimpleCloneInfo;\n\npublic class RestoreBindingVisibilityInstr extends OneOperandInstr implements FixedArityInstr {\n    public RestoreBindingVisibilityInstr(Operand viz) {\n        super(Operation.RESTORE_BINDING_VIZ, viz);\n    }\n\n    public Operand getVisibility() {\n        return getOperand1();\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return ii instanceof SimpleCloneInfo ? this : NopInstr.NOP;  // FIXME: Is this correct?\n    }\n\n    public static RestoreBindingVisibilityInstr decode(IRReaderDecoder d) {\n        return new RestoreBindingVisibilityInstr(d.decodeVariable());\n    }\n\n    @Override\n    public void encode(IRWriterEncoder e) {\n        super.encode(e);\n        e.encode(getVisibility());\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.RestoreBindingVisibilityInstr(this);\n    }\n}\n"
            }
        ],
        "SLOC": "36",
        "content": "package org.jruby.ir.instructions;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.persistence.IRReaderDecoder;\nimport org.jruby.ir.persistence.IRWriterEncoder;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\nimport org.jruby.ir.transformations.inlining.SimpleCloneInfo;\n\n/* Generic placeholder instruction for miscellaneous stuff that\n * needs to be done before a block's coded is executed. \n * Eventually, this should hopefully get folded away into other things. \n */\npublic class UpdateBlockExecutionStateInstr extends OneOperandInstr implements FixedArityInstr {\n    public UpdateBlockExecutionStateInstr(Operand self) {\n        super(Operation.UPDATE_BLOCK_STATE, self);\n    }\n\n    public Operand getSelf() {\n        return getOperand1();\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return ii instanceof SimpleCloneInfo ? this : NopInstr.NOP;  // FIXME: Is this correct?\n    }\n\n    public static UpdateBlockExecutionStateInstr decode(IRReaderDecoder d) {\n        return new UpdateBlockExecutionStateInstr(d.decodeVariable());\n    }\n\n    @Override\n    public void encode(IRWriterEncoder e) {\n        super.encode(e);\n        e.encode(getSelf());\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.UpdateBlockExecutionStateInstr(this);\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/boxing/BoxFixnumInstr.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/boxing/BoxBooleanInstr.java",
                "SLOC": "20",
                "content": "package org.jruby.ir.instructions.boxing;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.instructions.Instr;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.operands.Variable;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\n\npublic class BoxBooleanInstr extends BoxInstr {\n    public BoxBooleanInstr(Variable dst, Operand val) {\n        super(Operation.BOX_BOOLEAN, dst, val);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return new BoxBooleanInstr(ii.getRenamedVariable(getResult()), getValue().cloneForInlining(ii));\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.BoxBooleanInstr(this);\n    }\n}\n"
            }
        ],
        "SLOC": "20",
        "content": "package org.jruby.ir.instructions.boxing;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.instructions.Instr;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.operands.Variable;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\n\npublic class BoxFixnumInstr extends BoxInstr {\n    public BoxFixnumInstr(Variable dst, Operand val) {\n        super(Operation.BOX_FIXNUM, dst, val);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return new BoxFixnumInstr(ii.getRenamedVariable(getResult()), getValue().cloneForInlining(ii));\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.BoxFixnumInstr(this);\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/boxing/BoxFloatInstr.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/boxing/BoxBooleanInstr.java",
                "SLOC": "20",
                "content": "package org.jruby.ir.instructions.boxing;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.instructions.Instr;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.operands.Variable;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\n\npublic class BoxBooleanInstr extends BoxInstr {\n    public BoxBooleanInstr(Variable dst, Operand val) {\n        super(Operation.BOX_BOOLEAN, dst, val);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return new BoxBooleanInstr(ii.getRenamedVariable(getResult()), getValue().cloneForInlining(ii));\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.BoxBooleanInstr(this);\n    }\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/boxing/BoxFixnumInstr.java",
                "SLOC": "20",
                "content": "package org.jruby.ir.instructions.boxing;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.instructions.Instr;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.operands.Variable;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\n\npublic class BoxFixnumInstr extends BoxInstr {\n    public BoxFixnumInstr(Variable dst, Operand val) {\n        super(Operation.BOX_FIXNUM, dst, val);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return new BoxFixnumInstr(ii.getRenamedVariable(getResult()), getValue().cloneForInlining(ii));\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.BoxFixnumInstr(this);\n    }\n}\n"
            }
        ],
        "SLOC": "20",
        "content": "package org.jruby.ir.instructions.boxing;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.instructions.Instr;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.operands.Variable;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\n\npublic class BoxFloatInstr extends BoxInstr {\n    public BoxFloatInstr(Variable dst, Operand val) {\n        super(Operation.BOX_FLOAT, dst, val);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return new BoxFloatInstr(ii.getRenamedVariable(getResult()), getValue().cloneForInlining(ii));\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.BoxFloatInstr(this);\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/boxing/UnboxBooleanInstr.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/boxing/BoxBooleanInstr.java",
                "SLOC": "20",
                "content": "package org.jruby.ir.instructions.boxing;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.instructions.Instr;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.operands.Variable;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\n\npublic class BoxBooleanInstr extends BoxInstr {\n    public BoxBooleanInstr(Variable dst, Operand val) {\n        super(Operation.BOX_BOOLEAN, dst, val);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return new BoxBooleanInstr(ii.getRenamedVariable(getResult()), getValue().cloneForInlining(ii));\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.BoxBooleanInstr(this);\n    }\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/boxing/BoxFixnumInstr.java",
                "SLOC": "20",
                "content": "package org.jruby.ir.instructions.boxing;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.instructions.Instr;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.operands.Variable;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\n\npublic class BoxFixnumInstr extends BoxInstr {\n    public BoxFixnumInstr(Variable dst, Operand val) {\n        super(Operation.BOX_FIXNUM, dst, val);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return new BoxFixnumInstr(ii.getRenamedVariable(getResult()), getValue().cloneForInlining(ii));\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.BoxFixnumInstr(this);\n    }\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/boxing/BoxFloatInstr.java",
                "SLOC": "20",
                "content": "package org.jruby.ir.instructions.boxing;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.instructions.Instr;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.operands.Variable;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\n\npublic class BoxFloatInstr extends BoxInstr {\n    public BoxFloatInstr(Variable dst, Operand val) {\n        super(Operation.BOX_FLOAT, dst, val);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return new BoxFloatInstr(ii.getRenamedVariable(getResult()), getValue().cloneForInlining(ii));\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.BoxFloatInstr(this);\n    }\n}\n"
            }
        ],
        "SLOC": "20",
        "content": "package org.jruby.ir.instructions.boxing;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.instructions.Instr;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.operands.Variable;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\n\npublic class UnboxBooleanInstr extends UnboxInstr {\n    public UnboxBooleanInstr(Variable dst, Operand val) {\n        super(Operation.UNBOX_BOOLEAN, dst, val);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return new UnboxBooleanInstr(ii.getRenamedVariable(getResult()), getValue().cloneForInlining(ii));\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.UnboxBooleanInstr(this);\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/boxing/UnboxFixnumInstr.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/boxing/BoxBooleanInstr.java",
                "SLOC": "20",
                "content": "package org.jruby.ir.instructions.boxing;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.instructions.Instr;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.operands.Variable;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\n\npublic class BoxBooleanInstr extends BoxInstr {\n    public BoxBooleanInstr(Variable dst, Operand val) {\n        super(Operation.BOX_BOOLEAN, dst, val);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return new BoxBooleanInstr(ii.getRenamedVariable(getResult()), getValue().cloneForInlining(ii));\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.BoxBooleanInstr(this);\n    }\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/boxing/BoxFixnumInstr.java",
                "SLOC": "20",
                "content": "package org.jruby.ir.instructions.boxing;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.instructions.Instr;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.operands.Variable;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\n\npublic class BoxFixnumInstr extends BoxInstr {\n    public BoxFixnumInstr(Variable dst, Operand val) {\n        super(Operation.BOX_FIXNUM, dst, val);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return new BoxFixnumInstr(ii.getRenamedVariable(getResult()), getValue().cloneForInlining(ii));\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.BoxFixnumInstr(this);\n    }\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/boxing/BoxFloatInstr.java",
                "SLOC": "20",
                "content": "package org.jruby.ir.instructions.boxing;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.instructions.Instr;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.operands.Variable;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\n\npublic class BoxFloatInstr extends BoxInstr {\n    public BoxFloatInstr(Variable dst, Operand val) {\n        super(Operation.BOX_FLOAT, dst, val);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return new BoxFloatInstr(ii.getRenamedVariable(getResult()), getValue().cloneForInlining(ii));\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.BoxFloatInstr(this);\n    }\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/boxing/UnboxBooleanInstr.java",
                "SLOC": "20",
                "content": "package org.jruby.ir.instructions.boxing;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.instructions.Instr;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.operands.Variable;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\n\npublic class UnboxBooleanInstr extends UnboxInstr {\n    public UnboxBooleanInstr(Variable dst, Operand val) {\n        super(Operation.UNBOX_BOOLEAN, dst, val);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return new UnboxBooleanInstr(ii.getRenamedVariable(getResult()), getValue().cloneForInlining(ii));\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.UnboxBooleanInstr(this);\n    }\n}\n"
            }
        ],
        "SLOC": "20",
        "content": "package org.jruby.ir.instructions.boxing;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.instructions.Instr;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.operands.Variable;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\n\npublic class UnboxFixnumInstr extends UnboxInstr {\n    public UnboxFixnumInstr(Variable dst, Operand val) {\n        super(Operation.UNBOX_FIXNUM, dst, val);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return new UnboxFixnumInstr(ii.getRenamedVariable(getResult()), getValue().cloneForInlining(ii));\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.UnboxFixnumInstr(this);\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/boxing/UnboxFloatInstr.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/boxing/BoxBooleanInstr.java",
                "SLOC": "20",
                "content": "package org.jruby.ir.instructions.boxing;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.instructions.Instr;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.operands.Variable;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\n\npublic class BoxBooleanInstr extends BoxInstr {\n    public BoxBooleanInstr(Variable dst, Operand val) {\n        super(Operation.BOX_BOOLEAN, dst, val);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return new BoxBooleanInstr(ii.getRenamedVariable(getResult()), getValue().cloneForInlining(ii));\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.BoxBooleanInstr(this);\n    }\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/boxing/BoxFixnumInstr.java",
                "SLOC": "20",
                "content": "package org.jruby.ir.instructions.boxing;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.instructions.Instr;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.operands.Variable;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\n\npublic class BoxFixnumInstr extends BoxInstr {\n    public BoxFixnumInstr(Variable dst, Operand val) {\n        super(Operation.BOX_FIXNUM, dst, val);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return new BoxFixnumInstr(ii.getRenamedVariable(getResult()), getValue().cloneForInlining(ii));\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.BoxFixnumInstr(this);\n    }\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/boxing/BoxFloatInstr.java",
                "SLOC": "20",
                "content": "package org.jruby.ir.instructions.boxing;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.instructions.Instr;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.operands.Variable;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\n\npublic class BoxFloatInstr extends BoxInstr {\n    public BoxFloatInstr(Variable dst, Operand val) {\n        super(Operation.BOX_FLOAT, dst, val);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return new BoxFloatInstr(ii.getRenamedVariable(getResult()), getValue().cloneForInlining(ii));\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.BoxFloatInstr(this);\n    }\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/boxing/UnboxBooleanInstr.java",
                "SLOC": "20",
                "content": "package org.jruby.ir.instructions.boxing;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.instructions.Instr;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.operands.Variable;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\n\npublic class UnboxBooleanInstr extends UnboxInstr {\n    public UnboxBooleanInstr(Variable dst, Operand val) {\n        super(Operation.UNBOX_BOOLEAN, dst, val);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return new UnboxBooleanInstr(ii.getRenamedVariable(getResult()), getValue().cloneForInlining(ii));\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.UnboxBooleanInstr(this);\n    }\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/boxing/UnboxFixnumInstr.java",
                "SLOC": "20",
                "content": "package org.jruby.ir.instructions.boxing;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.instructions.Instr;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.operands.Variable;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\n\npublic class UnboxFixnumInstr extends UnboxInstr {\n    public UnboxFixnumInstr(Variable dst, Operand val) {\n        super(Operation.UNBOX_FIXNUM, dst, val);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return new UnboxFixnumInstr(ii.getRenamedVariable(getResult()), getValue().cloneForInlining(ii));\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.UnboxFixnumInstr(this);\n    }\n}\n"
            }
        ],
        "SLOC": "20",
        "content": "package org.jruby.ir.instructions.boxing;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.instructions.Instr;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.operands.Variable;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\n\npublic class UnboxFloatInstr extends UnboxInstr {\n    public UnboxFloatInstr(Variable dst, Operand val) {\n        super(Operation.UNBOX_FLOAT, dst, val);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return new UnboxFloatInstr(ii.getRenamedVariable(getResult()), getValue().cloneForInlining(ii));\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.UnboxFloatInstr(this);\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/specialized/OneFloatArgNoBlockCallInstr.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/specialized/OneFixnumArgNoBlockCallInstr.java",
                "SLOC": "45",
                "content": "package org.jruby.ir.instructions.specialized;\n\nimport org.jruby.RubySymbol;\nimport org.jruby.ir.IRScope;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.instructions.CallInstr;\nimport org.jruby.ir.instructions.Instr;\nimport org.jruby.ir.operands.Fixnum;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.operands.Variable;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\nimport org.jruby.parser.StaticScope;\nimport org.jruby.runtime.CallSite;\nimport org.jruby.runtime.CallType;\nimport org.jruby.runtime.DynamicScope;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\n\npublic class OneFixnumArgNoBlockCallInstr extends CallInstr {\n    private final long fixNum;\n\n    // clone constructor\n    protected OneFixnumArgNoBlockCallInstr(IRScope scope, CallType callType, Variable result, RubySymbol name,\n                                        Operand receiver, Operand[] args, boolean potentiallyRefined, CallSite callSite,\n                                        long callSiteId) {\n        super(scope, Operation.CALL_1F, callType, result, name, receiver, args, null, potentiallyRefined, callSite, callSiteId);\n\n        fixNum = ((Fixnum) args[0]).value;\n    }\n\n    // normal constructor\n    public OneFixnumArgNoBlockCallInstr(IRScope scope, CallType callType, Variable result, RubySymbol name, Operand receiver, Operand[] args, boolean potentiallyRefined) {\n        super(scope, Operation.CALL_1F, callType, result, name, receiver, args, null, potentiallyRefined);\n\n        assert args.length == 1;\n\n        this.fixNum = ((Fixnum) args[0]).value;\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return new OneFixnumArgNoBlockCallInstr(ii.getScope(), getCallType(), ii.getRenamedVariable(result), getName(),\n                getReceiver().cloneForInlining(ii), cloneCallArgs(ii), isPotentiallyRefined(), callSite, callSiteId);\n    }\n\n    public long getFixnumArg() {\n        return fixNum;\n    }\n\n    @Override\n    public Object interpret(ThreadContext context, StaticScope currScope, DynamicScope dynamicScope, IRubyObject self, Object[] temp) {\n        IRubyObject object = (IRubyObject) getReceiver().retrieve(context, self, currScope, dynamicScope, temp);\n        return getCallSite().call(context, self, object, fixNum);\n    }\n}\n"
            }
        ],
        "SLOC": "46",
        "content": "package org.jruby.ir.instructions.specialized;\n\nimport org.jruby.RubySymbol;\nimport org.jruby.ir.IRScope;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.instructions.CallInstr;\nimport org.jruby.ir.instructions.Instr;\nimport org.jruby.ir.operands.Float;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.operands.Variable;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\nimport org.jruby.parser.StaticScope;\nimport org.jruby.runtime.CallSite;\nimport org.jruby.runtime.CallType;\nimport org.jruby.runtime.DynamicScope;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\n\npublic class OneFloatArgNoBlockCallInstr extends CallInstr {\n    private final double flote;\n\n    // clone constructor\n    protected OneFloatArgNoBlockCallInstr(IRScope scope, CallType callType, Variable result, RubySymbol name,\n                                          Operand receiver, Operand[] args, boolean potentiallyRefined,\n                                          CallSite callSite, long callSiteId) {\n        super(scope, Operation.CALL_1D, callType, result, name, receiver, args, null, potentiallyRefined, callSite, callSiteId);\n\n        this.flote = ((Float) args[0]).value;\n    }\n\n    // normal constructor\n    public OneFloatArgNoBlockCallInstr(IRScope scope, CallType callType, Variable result, RubySymbol name, Operand receiver, Operand[] args,\n                                       boolean potentiallyRefined) {\n        super(scope, Operation.CALL_1D, callType, result, name, receiver, args, null, potentiallyRefined);\n\n        assert args.length == 1;\n\n        this.flote = ((Float) args[0]).value;\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return new OneFloatArgNoBlockCallInstr(ii.getScope(), getCallType(), ii.getRenamedVariable(result), getName(),\n                getReceiver().cloneForInlining(ii), cloneCallArgs(ii), isPotentiallyRefined(), getCallSite(), getCallSiteId());\n    }\n\n    public double getFloatArg() {\n        return flote;\n    }\n\n    @Override\n    public Object interpret(ThreadContext context, StaticScope currScope, DynamicScope dynamicScope, IRubyObject self, Object[] temp) {\n        IRubyObject object = (IRubyObject) getReceiver().retrieve(context, self, currScope, dynamicScope, temp);\n        return getCallSite().call(context, self, object, flote);\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/specialized/ZeroOperandArgNoBlockCallInstr.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/specialized/OneOperandArgNoBlockCallInstr.java",
                "SLOC": "44",
                "content": "package org.jruby.ir.instructions.specialized;\n\nimport org.jruby.RubySymbol;\nimport org.jruby.ir.IRScope;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.instructions.CallInstr;\nimport org.jruby.ir.instructions.Instr;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.operands.Variable;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\nimport org.jruby.parser.StaticScope;\nimport org.jruby.runtime.CallSite;\nimport org.jruby.runtime.CallType;\nimport org.jruby.runtime.DynamicScope;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\n\npublic class OneOperandArgNoBlockCallInstr extends CallInstr {\n    // specific instr constructor\n    public OneOperandArgNoBlockCallInstr(IRScope scope, CallType callType, Variable result, RubySymbol name, Operand receiver,\n                                         Operand[] args, boolean isPotentiallyRefined) {\n        this(scope, Operation.CALL_1O, callType, result, name, receiver, args, isPotentiallyRefined);\n    }\n\n    // clone constructor\n    public OneOperandArgNoBlockCallInstr(IRScope scope, Operation op, CallType callType, Variable result, RubySymbol name, Operand receiver,\n                                         Operand[] args, boolean isPotentiallyRefined, CallSite callSite, long callSiteId) {\n        super(scope, op, callType, result, name, receiver, args, null, isPotentiallyRefined, callSite, callSiteId);\n    }\n\n    // normal constructor\n    public OneOperandArgNoBlockCallInstr(IRScope scope, Operation op, CallType callType, Variable result, RubySymbol name, Operand receiver,\n                                         Operand[] args, boolean isPotentiallyRefined) {\n        super(scope, op, callType, result, name, receiver, args, null, isPotentiallyRefined);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return new OneOperandArgNoBlockCallInstr(ii.getScope(), Operation.CALL_1O, getCallType(),\n                ii.getRenamedVariable(result), getName(), getReceiver().cloneForInlining(ii), cloneCallArgs(ii),\n                isPotentiallyRefined(), getCallSite(), getCallSiteId());\n    }\n\n    @Override\n    public Object interpret(ThreadContext context, StaticScope currScope, DynamicScope dynamicScope, IRubyObject self, Object[] temp) {\n        IRubyObject object = (IRubyObject) getReceiver().retrieve(context, self, currScope, dynamicScope, temp);\n        IRubyObject arg1 = (IRubyObject) getArg1().retrieve(context, self, currScope, dynamicScope, temp);\n        return getCallSite().call(context, self, object, arg1);\n    }\n}\n"
            }
        ],
        "SLOC": "44",
        "content": "package org.jruby.ir.instructions.specialized;\n\nimport org.jruby.RubySymbol;\nimport org.jruby.ir.IRScope;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.instructions.CallInstr;\nimport org.jruby.ir.instructions.Instr;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.operands.Variable;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\nimport org.jruby.parser.StaticScope;\nimport org.jruby.runtime.CallSite;\nimport org.jruby.runtime.CallType;\nimport org.jruby.runtime.DynamicScope;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\n\npublic class ZeroOperandArgNoBlockCallInstr extends CallInstr {\n    // clone constructor\n    public ZeroOperandArgNoBlockCallInstr(IRScope scope, Operation op, CallType callType, Variable result, RubySymbol name, Operand receiver,\n                                          Operand[] args, boolean isPotentiallyRefined, CallSite callSite, long callSiteId) {\n        super(scope, op, callType, result, name, receiver, args, null, isPotentiallyRefined, callSite, callSiteId);\n    }\n\n    // normal constructor\n    protected ZeroOperandArgNoBlockCallInstr(IRScope scope, Operation op, CallType callType, Variable result, RubySymbol name, Operand receiver,\n                                          Operand[] args, boolean isPotentiallyRefined) {\n        super(scope, op, callType, result, name, receiver, args, null, isPotentiallyRefined);\n    }\n\n    // normal constructor\n    public ZeroOperandArgNoBlockCallInstr(IRScope scope, CallType callType, Variable result, RubySymbol name, Operand receiver,\n                                          Operand[] args, boolean isPotentiallyRefined) {\n        super(scope, Operation.CALL_0O, callType, result, name, receiver, args, null, isPotentiallyRefined);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        ZeroOperandArgNoBlockCallInstr zeroOperandArgNoBlockCallInstr = new ZeroOperandArgNoBlockCallInstr(ii.getScope(), getOperation(), getCallType(), ii.getRenamedVariable(result), getName(),\n                getReceiver().cloneForInlining(ii), cloneCallArgs(ii), isPotentiallyRefined(), getCallSite(), getCallSiteId());\n\n        zeroOperandArgNoBlockCallInstr.setProcNew(procNew);\n\n        return zeroOperandArgNoBlockCallInstr;\n    }\n\n    @Override\n    public Object interpret(ThreadContext context, StaticScope currScope, DynamicScope dynamicScope, IRubyObject self, Object[] temp) {\n        IRubyObject object = (IRubyObject) getReceiver().retrieve(context, self, currScope, dynamicScope, temp);\n\n        return getCallSite().call(context, self, object);\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/operands/TemporaryFloatVariable.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/operands/TemporaryFixnumVariable.java",
                "SLOC": "60",
                "content": "/*\n **** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2014 The JRuby Team (admin@jruby.org)\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ir.operands;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.persistence.IRReaderDecoder;\nimport org.jruby.ir.transformations.inlining.SimpleCloneInfo;\n\n/**\n * Represents a temporary variable for an unboxed Fixnum operand.\n */\npublic class TemporaryFixnumVariable extends TemporaryLocalVariable {\n    public static final String PREFIX = \"%i_\";\n    public TemporaryFixnumVariable(int offset) {\n        super(offset);\n    }\n\n    @Override\n    public TemporaryVariableType getType() {\n        return TemporaryVariableType.FIXNUM;\n    }\n\n    @Override\n    public String getPrefix() {\n        return PREFIX;\n    }\n\n    @Override\n    public Variable clone(SimpleCloneInfo ii) {\n        return this;\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.TemporaryFixnumVariable(this);\n    }\n\n    public static TemporaryFixnumVariable decode(IRReaderDecoder d) {\n        return new TemporaryFixnumVariable(d.decodeInt());\n    }\n}\n"
            }
        ],
        "SLOC": "60",
        "content": "/*\n **** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2014 The JRuby Team (admin@jruby.org)\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ir.operands;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.persistence.IRReaderDecoder;\nimport org.jruby.ir.transformations.inlining.SimpleCloneInfo;\n\n/**\n * Represents a temporary variable for an unboxed Float operand.\n */\npublic class TemporaryFloatVariable extends TemporaryLocalVariable {\n    public static final String PREFIX = \"%f_\";\n    public TemporaryFloatVariable(int offset) {\n        super(offset);\n    }\n\n    @Override\n    public TemporaryVariableType getType() {\n        return TemporaryVariableType.FLOAT;\n    }\n\n    @Override\n    public String getPrefix() {\n        return PREFIX;\n    }\n\n    @Override\n    public Variable clone(SimpleCloneInfo ii) {\n        return this;\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.TemporaryFloatVariable(this);\n    }\n\n    public static TemporaryFloatVariable decode(IRReaderDecoder d) {\n        return new TemporaryFloatVariable(d.decodeInt());\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/targets/JVM7.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/targets/JVM6.java",
                "SLOC": "16",
                "content": "package org.jruby.ir.targets;\n\nimport org.jruby.RubyInstanceConfig;\nimport org.objectweb.asm.ClassWriter;\n\nimport static org.jruby.util.CodegenUtils.p;\nimport static org.objectweb.asm.Opcodes.ACC_PUBLIC;\nimport static org.objectweb.asm.Opcodes.ACC_SUPER;\n\n// This class represents JDK6 as the compiler target\n// JDK6 has no support for invokedynamic\npublic class JVM6 extends JVM {\n    public void pushscript(String clsName, String filename) {\n        writer = new ClassWriter(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);\n        clsStack.push(new ClassData6(clsName, writer));\n\n        cls().visit(RubyInstanceConfig.JAVA_VERSION, ACC_PUBLIC + ACC_SUPER, clsName, null, p(Object.class), null);\n        cls().visitSource(filename, null);\n    }\n}\n"
            }
        ],
        "SLOC": "17",
        "content": "package org.jruby.ir.targets;\n\nimport org.jruby.RubyInstanceConfig;\nimport org.objectweb.asm.ClassWriter;\n\nimport java.io.PrintWriter;\n\nimport static org.jruby.util.CodegenUtils.p;\nimport static org.objectweb.asm.Opcodes.ACC_PUBLIC;\nimport static org.objectweb.asm.Opcodes.ACC_SUPER;\n\n// This class represents JDK7 as the compiler target\n// JDK7 supports invokedynamic for example\npublic class JVM7 extends JVM {\n    public void pushscript(String clsName, String filename) {\n        writer = new ClassWriter(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);\n        clsStack.push(new ClassData7(clsName, writer));\n\n        cls().visit(RubyInstanceConfig.JAVA_VERSION, ACC_PUBLIC + ACC_SUPER, clsName, null, p(Object.class), null);\n        cls().visitSource(filename, null);\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/targets/SymbolProcObjectSite.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/targets/SymbolObjectSite.java",
                "SLOC": "43",
                "content": "package org.jruby.ir.targets;\n\nimport org.jcodings.Encoding;\nimport org.jruby.RubyEncoding;\nimport org.jruby.RubySymbol;\nimport org.jruby.ir.runtime.IRRuntimeHelpers;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport org.jruby.util.ByteList;\nimport org.objectweb.asm.Handle;\nimport org.objectweb.asm.Opcodes;\n\nimport java.lang.invoke.CallSite;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.invoke.MethodType;\n\nimport static org.jruby.util.CodegenUtils.p;\nimport static org.jruby.util.CodegenUtils.sig;\n\n/**\n* Created by headius on 10/23/14.\n*/\npublic class SymbolObjectSite extends LazyObjectSite {\n    private final String value;\n    private final String encoding;\n\n    public SymbolObjectSite(MethodType type, String value, String encoding) {\n        super(type);\n\n        this.value = value;\n        this.encoding = encoding;\n    }\n\n    public static final Handle BOOTSTRAP = new Handle(\n            Opcodes.H_INVOKESTATIC,\n            p(SymbolObjectSite.class),\n            \"bootstrap\",\n            sig(CallSite.class, MethodHandles.Lookup.class, String.class, MethodType.class, String.class, String.class),\n            false);\n\n    public static CallSite bootstrap(MethodHandles.Lookup lookup, String name, MethodType type, String value, String encoding) {\n        return new SymbolObjectSite(type, value, encoding).bootstrap(lookup);\n    }\n\n    public IRubyObject construct(ThreadContext context) {\n        return RubySymbol.newSymbol(context.runtime,\n                new ByteList(\n                        RubyEncoding.encodeISO(value),\n                        IRRuntimeHelpers.retrieveJCodingsEncoding(context, encoding),\n                        false));\n    }\n}\n"
            }
        ],
        "SLOC": "40",
        "content": "package org.jruby.ir.targets;\n\nimport org.jruby.RubyEncoding;\nimport org.jruby.RubySymbol;\nimport org.jruby.ir.runtime.IRRuntimeHelpers;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport org.jruby.util.ByteList;\nimport org.objectweb.asm.Handle;\nimport org.objectweb.asm.Opcodes;\n\nimport java.lang.invoke.CallSite;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.invoke.MethodType;\n\nimport static org.jruby.util.CodegenUtils.p;\nimport static org.jruby.util.CodegenUtils.sig;\n\npublic class SymbolProcObjectSite extends LazyObjectSite {\n    private final String value;\n    private final String encoding;\n\n    public SymbolProcObjectSite(MethodType type, String value, String encoding) {\n        super(type);\n\n        this.value = value;\n        this.encoding = encoding;\n    }\n\n    public static final Handle BOOTSTRAP = new Handle(\n            Opcodes.H_INVOKESTATIC,\n            p(SymbolProcObjectSite.class),\n            \"bootstrap\",\n            sig(CallSite.class, MethodHandles.Lookup.class, String.class, MethodType.class, String.class, String.class),\n            false);\n\n    public static CallSite bootstrap(MethodHandles.Lookup lookup, String name, MethodType type, String value, String encoding) {\n        return new SymbolProcObjectSite(type, value, encoding).bootstrap(lookup);\n    }\n\n    public IRubyObject construct(ThreadContext context) {\n        RubySymbol symbol = RubySymbol.newSymbol(context.runtime,\n                new ByteList(\n                        RubyEncoding.encodeISO(value),\n                        IRRuntimeHelpers.retrieveJCodingsEncoding(context, encoding),\n                        false));\n        return IRRuntimeHelpers.newSymbolProc(context, symbol);\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/targets/ZSuperInvokeSite.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/targets/UnresolvedSuperInvokeSite.java",
                "SLOC": "23",
                "content": "package org.jruby.ir.targets;\n\nimport org.jruby.RubyClass;\nimport org.jruby.ir.runtime.IRRuntimeHelpers;\nimport org.jruby.runtime.Block;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\n\nimport java.lang.invoke.MethodType;\n\n/**\n* Created by headius on 10/23/14.\n*/\npublic class UnresolvedSuperInvokeSite extends SuperInvokeSite {\n    public UnresolvedSuperInvokeSite(MethodType type, String name, String splatmapString, String file, int line) {\n        super(type, name, splatmapString, file, line);\n    }\n\n    public IRubyObject invoke(ThreadContext context, IRubyObject caller, IRubyObject self, RubyClass definingModule, IRubyObject[] args, Block block) throws Throwable {\n        // TODO: get rid of caller\n        // TODO: caching\n        return IRRuntimeHelpers.unresolvedSuperSplatArgs(context, self, args, block, splatMap);\n    }\n\n    public IRubyObject fail(ThreadContext context, IRubyObject caller, IRubyObject self, RubyClass definingModule, IRubyObject[] args, Block block) throws Throwable {\n        return invoke(context, caller, self, definingModule, args, block);\n    }\n}\n"
            }
        ],
        "SLOC": "24",
        "content": "package org.jruby.ir.targets;\n\nimport org.jruby.RubyClass;\nimport org.jruby.ir.runtime.IRRuntimeHelpers;\nimport org.jruby.runtime.Block;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\n\nimport java.lang.invoke.MethodType;\n\n/**\n* Created by headius on 10/23/14.\n*/\npublic class ZSuperInvokeSite extends SuperInvokeSite {\n    public ZSuperInvokeSite(MethodType type, String name, String splatmapString, String file, int line) {\n        super(type, name, splatmapString, file, line);\n    }\n\n    public IRubyObject invoke(ThreadContext context, IRubyObject caller, IRubyObject self, RubyClass definingModule, IRubyObject[] args, Block block) throws Throwable {\n        // TODO: get rid of caller\n        // TODO: caching\n        if (block == null || !block.isGiven()) block = context.getFrameBlock();\n        return IRRuntimeHelpers.zSuperSplatArgs(context, self, args, block, splatMap);\n    }\n\n    public IRubyObject fail(ThreadContext context, IRubyObject caller, IRubyObject self, RubyClass definingModule, IRubyObject[] args, Block block) throws Throwable {\n        return invoke(context, caller, self, definingModule, args, block);\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/java/invokers/SingletonMethodInvoker.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/java/invokers/InstanceMethodInvoker.java",
                "SLOC": "130",
                "content": "package org.jruby.java.invokers;\n\nimport java.lang.reflect.Method;\nimport java.util.function.Supplier;\n\nimport org.jruby.RubyModule;\nimport org.jruby.RubyProc;\nimport org.jruby.java.proxies.JavaProxy;\nimport org.jruby.javasupport.JavaMethod;\nimport org.jruby.runtime.Block;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport org.jruby.util.ArraySupport;\n\npublic final class InstanceMethodInvoker extends MethodInvoker {\n    public InstanceMethodInvoker(RubyModule host, Supplier<Method[]> methods, String name) {\n        super(host, methods, name);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args) {\n        JavaProxy proxy = castJavaProxy(self);\n        JavaMethod method = (JavaMethod) findCallable(self, name, args, args.length);\n        return method.invokeDirect( context, proxy.getObject(), convertArguments(method, args) );\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name) {\n        if (javaVarargsCallables != null) return call(context, self, clazz, name, IRubyObject.NULL_ARRAY);\n        JavaProxy proxy = castJavaProxy(self);\n        JavaMethod method = (JavaMethod) findCallableArityZero(self, name);\n        return method.invokeDirect(context, proxy.getObject());\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0) {\n        if (javaVarargsCallables != null) return call(context, self, clazz, name, new IRubyObject[] {arg0});\n        JavaProxy proxy = castJavaProxy(self);\n        JavaMethod method = (JavaMethod) findCallableArityOne(self, name, arg0);\n        final Class<?>[] paramTypes = method.getParameterTypes();\n        Object cArg0 = arg0.toJava(paramTypes[0]);\n        return method.invokeDirect(context, proxy.getObject(), cArg0);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1) {\n        if (javaVarargsCallables != null) return call(context, self, clazz, name, new IRubyObject[] {arg0, arg1});\n        JavaProxy proxy = castJavaProxy(self);\n        JavaMethod method = (JavaMethod) findCallableArityTwo(self, name, arg0, arg1);\n        final Class<?>[] paramTypes = method.getParameterTypes();\n        Object cArg0 = arg0.toJava(paramTypes[0]);\n        Object cArg1 = arg1.toJava(paramTypes[1]);\n        return method.invokeDirect(context, proxy.getObject(), cArg0, cArg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1, IRubyObject arg2) {\n        if (javaVarargsCallables != null) return call(context, self, clazz, name, new IRubyObject[] {arg0, arg1, arg2});\n        JavaProxy proxy = castJavaProxy(self);\n        JavaMethod method = (JavaMethod) findCallableArityThree(self, name, arg0, arg1, arg2);\n        final Class<?>[] paramTypes = method.getParameterTypes();\n        Object cArg0 = arg0.toJava(paramTypes[0]);\n        Object cArg1 = arg1.toJava(paramTypes[1]);\n        Object cArg2 = arg2.toJava(paramTypes[2]);\n        return method.invokeDirect(context, proxy.getObject(), cArg0, cArg1, cArg2);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args, Block block) {\n        if ( block.isGiven() ) {\n            JavaProxy proxy = castJavaProxy(self);\n            final int len = args.length;\n            // these extra arrays are really unfortunate; split some of these paths out to eliminate?\n            IRubyObject[] newArgs = ArraySupport.newCopy(args, RubyProc.newProc(context.runtime, block, block.type));\n\n            JavaMethod method = (JavaMethod) findCallable(self, name, newArgs, len + 1);\n            final Class<?>[] paramTypes = method.getParameterTypes();\n\n            Object[] convertedArgs = new Object[len + 1];\n            for (int i = 0; i < len + 1; i++) {\n                convertedArgs[i] = newArgs[i].toJava(paramTypes[i]);\n            }\n\n            return method.invokeDirect(context, proxy.getObject(), convertedArgs);\n        }\n        return call(context, self, clazz, name, args);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, Block block) {\n        if (block.isGiven()) {\n            JavaProxy proxy = castJavaProxy(self);\n            RubyProc proc = RubyProc.newProc(context.runtime, block, block.type);\n            JavaMethod method = (JavaMethod) findCallableArityOne(self, name, proc);\n            final Class<?>[] paramTypes = method.getParameterTypes();\n            Object cArg0 = proc.toJava(paramTypes[0]);\n            return method.invokeDirect(context, proxy.getObject(), cArg0);\n        }\n        return call(context, self, clazz, name);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, Block block) {\n        if (block.isGiven()) {\n            JavaProxy proxy = castJavaProxy(self);\n            RubyProc proc = RubyProc.newProc(context.runtime, block, block.type);\n            JavaMethod method = (JavaMethod) findCallableArityTwo(self, name, arg0, proc);\n            final Class<?>[] paramTypes = method.getParameterTypes();\n            Object cArg0 = arg0.toJava(paramTypes[0]);\n            Object cArg1 = proc.toJava(paramTypes[1]);\n            return method.invokeDirect(context, proxy.getObject(), cArg0, cArg1);\n        }\n        return call(context, self, clazz, name, arg0);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1, Block block) {\n        if (block.isGiven()) {\n            JavaProxy proxy = castJavaProxy(self);\n            RubyProc proc = RubyProc.newProc(context.runtime, block, block.type);\n            JavaMethod method = (JavaMethod) findCallableArityThree(self, name, arg0, arg1, proc);\n            final Class<?>[] paramTypes = method.getParameterTypes();\n            Object cArg0 = arg0.toJava(paramTypes[0]);\n            Object cArg1 = arg1.toJava(paramTypes[1]);\n            Object cArg2 = proc.toJava(paramTypes[2]);\n            return method.invokeDirect(context, proxy.getObject(), cArg0, cArg1, cArg2);\n        }\n        return call(context, self, clazz, name, arg0, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1, IRubyObject arg2, Block block) {\n        if (block.isGiven()) {\n            JavaProxy proxy = castJavaProxy(self);\n            RubyProc proc = RubyProc.newProc(context.runtime, block, block.type);\n            JavaMethod method = (JavaMethod)findCallableArityFour(self, name, arg0, arg1, arg2, proc);\n            final Class<?>[] paramTypes = method.getParameterTypes();\n            Object cArg0 = arg0.toJava(paramTypes[0]);\n            Object cArg1 = arg1.toJava(paramTypes[1]);\n            Object cArg2 = arg2.toJava(paramTypes[2]);\n            Object cArg3 = proc.toJava(paramTypes[3]);\n            return method.invokeDirect(context, proxy.getObject(), cArg0, cArg1, cArg2, cArg3);\n        }\n        return call(context, self, clazz, name, arg0, arg1, arg2);\n    }\n}\n"
            }
        ],
        "SLOC": "125",
        "content": "package org.jruby.java.invokers;\n\nimport java.lang.reflect.Method;\nimport java.util.List;\nimport java.util.function.Supplier;\n\nimport org.jruby.RubyClass;\nimport org.jruby.RubyModule;\nimport org.jruby.RubyProc;\nimport org.jruby.javasupport.JavaMethod;\nimport org.jruby.runtime.Block;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\n\npublic final class SingletonMethodInvoker extends MethodInvoker {\n\n    private final Object singleton;\n\n    public SingletonMethodInvoker(Object singleton, RubyClass host, Supplier<Method[]> methods, String name) {\n        super(host, methods, name);\n        this.singleton = singleton;\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args) {\n        JavaMethod method = (JavaMethod) findCallable(self, name, args, args.length);\n        return method.invokeDirect( context, singleton, convertArguments(method, args) );\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name) {\n        if (javaVarargsCallables != null) return call(context, self, clazz, name, IRubyObject.NULL_ARRAY);\n        JavaMethod method = (JavaMethod) findCallableArityZero(self, name);\n\n        return method.invokeDirect(context, singleton);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0) {\n        if (javaVarargsCallables != null) return call(context, self, clazz, name, new IRubyObject[] {arg0});\n        JavaMethod method = (JavaMethod) findCallableArityOne(self, name, arg0);\n        if (method.isVarArgs()) return call(context, self, clazz, name, new IRubyObject[] {arg0});\n        final Class<?>[] paramTypes = method.getParameterTypes();\n        Object cArg0 = arg0.toJava(paramTypes[0]);\n\n        return method.invokeDirect(context, singleton, cArg0);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1) {\n        if (javaVarargsCallables != null) return call(context, self, clazz, name, new IRubyObject[] {arg0, arg1});\n        JavaMethod method = (JavaMethod)findCallableArityTwo(self, name, arg0, arg1);\n        final Class<?>[] paramTypes = method.getParameterTypes();\n        Object cArg0 = arg0.toJava(paramTypes[0]);\n        Object cArg1 = arg1.toJava(paramTypes[1]);\n\n        return method.invokeDirect(context, singleton, cArg0, cArg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1, IRubyObject arg2) {\n        if (javaVarargsCallables != null) return call(context, self, clazz, name, new IRubyObject[] {arg0, arg1, arg2});\n        JavaMethod method = (JavaMethod) findCallableArityThree(self, name, arg0, arg1, arg2);\n        final Class<?>[] paramTypes = method.getParameterTypes();\n        Object cArg0 = arg0.toJava(paramTypes[0]);\n        Object cArg1 = arg1.toJava(paramTypes[1]);\n        Object cArg2 = arg2.toJava(paramTypes[2]);\n\n        return method.invokeDirect(context, singleton, cArg0, cArg1, cArg2);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args, Block block) {\n        if (block.isGiven()) {\n            int len = args.length;\n            // too much array creation!\n            Object[] convertedArgs = new Object[len + 1];\n            IRubyObject[] intermediate = new IRubyObject[len + 1];\n            System.arraycopy(args, 0, intermediate, 0, len);\n            intermediate[len] = RubyProc.newProc(context.runtime, block, block.type);\n\n            JavaMethod method = (JavaMethod) findCallable(self, name, intermediate, len + 1);\n            final Class<?>[] paramTypes = method.getParameterTypes();\n            for (int i = 0; i < len + 1; i++) {\n                convertedArgs[i] = intermediate[i].toJava(paramTypes[i]);\n            }\n\n            return method.invokeDirect(context, singleton, convertedArgs);\n        }\n        return call(context, self, clazz, name, args);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, Block block) {\n        if (block.isGiven()) {\n            RubyProc proc = RubyProc.newProc(context.runtime, block, block.type);\n            JavaMethod method = (JavaMethod) findCallableArityOne(self, name, proc);\n            final Class<?>[] paramTypes = method.getParameterTypes();\n            Object cArg0 = proc.toJava(paramTypes[0]);\n\n            return method.invokeDirect(context, singleton, cArg0);\n        }\n        return call(context, self, clazz, name);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, Block block) {\n        if (block.isGiven()) {\n            RubyProc proc = RubyProc.newProc(context.runtime, block, block.type);\n            JavaMethod method = (JavaMethod) findCallableArityTwo(self, name, arg0, proc);\n            final Class<?>[] paramTypes = method.getParameterTypes();\n            Object cArg0 = arg0.toJava(paramTypes[0]);\n            Object cArg1 = proc.toJava(paramTypes[1]);\n\n            return method.invokeDirect(context, singleton, cArg0, cArg1);\n        }\n        return call(context, self, clazz, name, arg0);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1, Block block) {\n        if (block.isGiven()) {\n            RubyProc proc = RubyProc.newProc(context.runtime, block, block.type);\n            JavaMethod method = (JavaMethod) findCallableArityThree(self, name, arg0, arg1, proc);\n            final Class<?>[] paramTypes = method.getParameterTypes();\n            Object cArg0 = arg0.toJava(paramTypes[0]);\n            Object cArg1 = arg1.toJava(paramTypes[1]);\n            Object cArg2 = proc.toJava(paramTypes[2]);\n\n            return method.invokeDirect(context, singleton, cArg0, cArg1, cArg2);\n        }\n        return call(context, self, clazz, name, arg0, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1, IRubyObject arg2, Block block) {\n        if (block.isGiven()) {\n            RubyProc proc = RubyProc.newProc(context.runtime, block, block.type);\n            JavaMethod method = (JavaMethod) findCallableArityFour(self, name, arg0, arg1, arg2, proc);\n            final Class<?>[] paramTypes = method.getParameterTypes();\n            Object cArg0 = arg0.toJava(paramTypes[0]);\n            Object cArg1 = arg1.toJava(paramTypes[1]);\n            Object cArg2 = arg2.toJava(paramTypes[2]);\n            Object cArg3 = proc.toJava(paramTypes[3]);\n\n            return method.invokeDirect(context, singleton, cArg0, cArg1, cArg2, cArg3);\n        }\n        return call(context, self, clazz, name, arg0, arg1, arg2);\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/java/invokers/StaticFieldSetter.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/java/invokers/InstanceFieldSetter.java",
                "SLOC": "20",
                "content": "package org.jruby.java.invokers;\n\nimport java.lang.reflect.Field;\n\nimport org.jruby.RubyModule;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\n\npublic class InstanceFieldSetter extends FieldMethodOne {\n\n    public InstanceFieldSetter(String name, RubyModule host, Field field) {\n        super(name, host, field);\n    }\n\n    @Override\n    public final IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg) {\n        try {\n            Object value = arg.toJava(field.getType());\n            field.set(retrieveTarget(self), value);\n        }\n        catch (IllegalAccessException ex) { return handleSetException(context.runtime, ex); }\n        catch (IllegalArgumentException ex) { return handleSetException(context.runtime, ex); }\n        return arg;\n    }\n\n}\n"
            }
        ],
        "SLOC": "19",
        "content": "package org.jruby.java.invokers;\n\nimport java.lang.reflect.Field;\n\nimport org.jruby.RubyModule;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\n\npublic class StaticFieldSetter extends FieldMethodOne {\n\n    public StaticFieldSetter(String name, RubyModule host, Field field) {\n        super(name, host, field);\n    }\n\n    @Override\n    public final IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg) {\n        try {\n            field.set(null, arg.toJava(field.getType()));\n        }\n        catch (IllegalAccessException ex) { return handleSetException(context.runtime, ex); }\n        catch (IllegalArgumentException ex) { return handleSetException(context.runtime, ex); }\n        return arg;\n    }\n\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/java/invokers/StaticMethodInvoker.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/java/invokers/SingletonMethodInvoker.java",
                "SLOC": "125",
                "content": "package org.jruby.java.invokers;\n\nimport java.lang.reflect.Method;\nimport java.util.List;\nimport java.util.function.Supplier;\n\nimport org.jruby.RubyClass;\nimport org.jruby.RubyModule;\nimport org.jruby.RubyProc;\nimport org.jruby.javasupport.JavaMethod;\nimport org.jruby.runtime.Block;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\n\npublic final class SingletonMethodInvoker extends MethodInvoker {\n\n    private final Object singleton;\n\n    public SingletonMethodInvoker(Object singleton, RubyClass host, Supplier<Method[]> methods, String name) {\n        super(host, methods, name);\n        this.singleton = singleton;\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args) {\n        JavaMethod method = (JavaMethod) findCallable(self, name, args, args.length);\n        return method.invokeDirect( context, singleton, convertArguments(method, args) );\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name) {\n        if (javaVarargsCallables != null) return call(context, self, clazz, name, IRubyObject.NULL_ARRAY);\n        JavaMethod method = (JavaMethod) findCallableArityZero(self, name);\n\n        return method.invokeDirect(context, singleton);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0) {\n        if (javaVarargsCallables != null) return call(context, self, clazz, name, new IRubyObject[] {arg0});\n        JavaMethod method = (JavaMethod) findCallableArityOne(self, name, arg0);\n        if (method.isVarArgs()) return call(context, self, clazz, name, new IRubyObject[] {arg0});\n        final Class<?>[] paramTypes = method.getParameterTypes();\n        Object cArg0 = arg0.toJava(paramTypes[0]);\n\n        return method.invokeDirect(context, singleton, cArg0);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1) {\n        if (javaVarargsCallables != null) return call(context, self, clazz, name, new IRubyObject[] {arg0, arg1});\n        JavaMethod method = (JavaMethod)findCallableArityTwo(self, name, arg0, arg1);\n        final Class<?>[] paramTypes = method.getParameterTypes();\n        Object cArg0 = arg0.toJava(paramTypes[0]);\n        Object cArg1 = arg1.toJava(paramTypes[1]);\n\n        return method.invokeDirect(context, singleton, cArg0, cArg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1, IRubyObject arg2) {\n        if (javaVarargsCallables != null) return call(context, self, clazz, name, new IRubyObject[] {arg0, arg1, arg2});\n        JavaMethod method = (JavaMethod) findCallableArityThree(self, name, arg0, arg1, arg2);\n        final Class<?>[] paramTypes = method.getParameterTypes();\n        Object cArg0 = arg0.toJava(paramTypes[0]);\n        Object cArg1 = arg1.toJava(paramTypes[1]);\n        Object cArg2 = arg2.toJava(paramTypes[2]);\n\n        return method.invokeDirect(context, singleton, cArg0, cArg1, cArg2);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args, Block block) {\n        if (block.isGiven()) {\n            int len = args.length;\n            // too much array creation!\n            Object[] convertedArgs = new Object[len + 1];\n            IRubyObject[] intermediate = new IRubyObject[len + 1];\n            System.arraycopy(args, 0, intermediate, 0, len);\n            intermediate[len] = RubyProc.newProc(context.runtime, block, block.type);\n\n            JavaMethod method = (JavaMethod) findCallable(self, name, intermediate, len + 1);\n            final Class<?>[] paramTypes = method.getParameterTypes();\n            for (int i = 0; i < len + 1; i++) {\n                convertedArgs[i] = intermediate[i].toJava(paramTypes[i]);\n            }\n\n            return method.invokeDirect(context, singleton, convertedArgs);\n        }\n        return call(context, self, clazz, name, args);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, Block block) {\n        if (block.isGiven()) {\n            RubyProc proc = RubyProc.newProc(context.runtime, block, block.type);\n            JavaMethod method = (JavaMethod) findCallableArityOne(self, name, proc);\n            final Class<?>[] paramTypes = method.getParameterTypes();\n            Object cArg0 = proc.toJava(paramTypes[0]);\n\n            return method.invokeDirect(context, singleton, cArg0);\n        }\n        return call(context, self, clazz, name);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, Block block) {\n        if (block.isGiven()) {\n            RubyProc proc = RubyProc.newProc(context.runtime, block, block.type);\n            JavaMethod method = (JavaMethod) findCallableArityTwo(self, name, arg0, proc);\n            final Class<?>[] paramTypes = method.getParameterTypes();\n            Object cArg0 = arg0.toJava(paramTypes[0]);\n            Object cArg1 = proc.toJava(paramTypes[1]);\n\n            return method.invokeDirect(context, singleton, cArg0, cArg1);\n        }\n        return call(context, self, clazz, name, arg0);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1, Block block) {\n        if (block.isGiven()) {\n            RubyProc proc = RubyProc.newProc(context.runtime, block, block.type);\n            JavaMethod method = (JavaMethod) findCallableArityThree(self, name, arg0, arg1, proc);\n            final Class<?>[] paramTypes = method.getParameterTypes();\n            Object cArg0 = arg0.toJava(paramTypes[0]);\n            Object cArg1 = arg1.toJava(paramTypes[1]);\n            Object cArg2 = proc.toJava(paramTypes[2]);\n\n            return method.invokeDirect(context, singleton, cArg0, cArg1, cArg2);\n        }\n        return call(context, self, clazz, name, arg0, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1, IRubyObject arg2, Block block) {\n        if (block.isGiven()) {\n            RubyProc proc = RubyProc.newProc(context.runtime, block, block.type);\n            JavaMethod method = (JavaMethod) findCallableArityFour(self, name, arg0, arg1, arg2, proc);\n            final Class<?>[] paramTypes = method.getParameterTypes();\n            Object cArg0 = arg0.toJava(paramTypes[0]);\n            Object cArg1 = arg1.toJava(paramTypes[1]);\n            Object cArg2 = arg2.toJava(paramTypes[2]);\n            Object cArg3 = proc.toJava(paramTypes[3]);\n\n            return method.invokeDirect(context, singleton, cArg0, cArg1, cArg2, cArg3);\n        }\n        return call(context, self, clazz, name, arg0, arg1, arg2);\n    }\n}\n"
            }
        ],
        "SLOC": "120",
        "content": "package org.jruby.java.invokers;\n\nimport java.lang.reflect.Method;\nimport java.util.function.Supplier;\n\nimport org.jruby.RubyModule;\nimport org.jruby.RubyProc;\nimport org.jruby.javasupport.JavaMethod;\nimport org.jruby.runtime.Block;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport org.jruby.util.ArraySupport;\n\npublic final class StaticMethodInvoker extends MethodInvoker {\n\n    public StaticMethodInvoker(RubyModule host, Supplier<Method[]> methods, String name) {\n        super(host, methods, name);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args) {\n        JavaMethod method = (JavaMethod) findCallable(self, name, args, args.length);\n        return method.invokeStaticDirect( context, convertArguments(method, args) );\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name) {\n        if (javaVarargsCallables != null) return call(context, self, clazz, name, IRubyObject.NULL_ARRAY);\n        JavaMethod method = (JavaMethod) findCallableArityZero(self, name);\n\n        return method.invokeStaticDirect(context);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0) {\n        if (javaVarargsCallables != null) return call(context, self, clazz, name, new IRubyObject[] {arg0});\n        JavaMethod method = (JavaMethod) findCallableArityOne(self, name, arg0);\n        if (method.isVarArgs()) return call(context, self, clazz, name, new IRubyObject[] {arg0});\n        final Class<?>[] paramTypes = method.getParameterTypes();\n        Object cArg0 = arg0.toJava(paramTypes[0]);\n\n        return method.invokeStaticDirect(context, cArg0);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1) {\n        if (javaVarargsCallables != null) return call(context, self, clazz, name, new IRubyObject[] {arg0, arg1});\n        JavaMethod method = (JavaMethod) findCallableArityTwo(self, name, arg0, arg1);\n        final Class<?>[] paramTypes = method.getParameterTypes();\n        Object cArg0 = arg0.toJava(paramTypes[0]);\n        Object cArg1 = arg1.toJava(paramTypes[1]);\n\n        return method.invokeStaticDirect(context, cArg0, cArg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1, IRubyObject arg2) {\n        if (javaVarargsCallables != null) return call(context, self, clazz, name, new IRubyObject[] {arg0, arg1, arg2});\n        JavaMethod method = (JavaMethod) findCallableArityThree(self, name, arg0, arg1, arg2);\n        final Class<?>[] paramTypes = method.getParameterTypes();\n        Object cArg0 = arg0.toJava(paramTypes[0]);\n        Object cArg1 = arg1.toJava(paramTypes[1]);\n        Object cArg2 = arg2.toJava(paramTypes[2]);\n\n        return method.invokeStaticDirect(context, cArg0, cArg1, cArg2);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args, Block block) {\n        if (block.isGiven()) {\n            final int len = args.length;\n            // too much array creation!\n            IRubyObject[] newArgs = ArraySupport.newCopy(args, RubyProc.newProc(context.runtime, block, block.type));\n\n            JavaMethod method = (JavaMethod) findCallable(self, name, newArgs, len + 1);\n            final Class<?>[] paramTypes = method.getParameterTypes();\n\n            Object[] convertedArgs = new Object[len + 1];\n            for (int i = 0; i < len + 1; i++) {\n                convertedArgs[i] = newArgs[i].toJava(paramTypes[i]);\n            }\n\n            return method.invokeStaticDirect(context, convertedArgs);\n        }\n        return call(context, self, clazz, name, args);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, Block block) {\n        if (block.isGiven()) {\n            RubyProc proc = RubyProc.newProc(context.runtime, block, block.type);\n            JavaMethod method = (JavaMethod) findCallableArityOne(self, name, proc);\n            final Class<?>[] paramTypes = method.getParameterTypes();\n            Object cArg0 = proc.toJava(paramTypes[0]);\n\n            return method.invokeStaticDirect(context, cArg0);\n        }\n        return call(context, self, clazz, name);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, Block block) {\n        if (block.isGiven()) {\n            RubyProc proc = RubyProc.newProc(context.runtime, block, block.type);\n            JavaMethod method = (JavaMethod) findCallableArityTwo(self, name, arg0, proc);\n            final Class<?>[] paramTypes = method.getParameterTypes();\n            Object cArg0 = arg0.toJava(paramTypes[0]);\n            Object cArg1 = proc.toJava(paramTypes[1]);\n\n            return method.invokeStaticDirect(context, cArg0, cArg1);\n        }\n        return call(context, self, clazz, name, arg0);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1, Block block) {\n        if (block.isGiven()) {\n            RubyProc proc = RubyProc.newProc(context.runtime, block, block.type);\n            JavaMethod method = (JavaMethod) findCallableArityThree(self, name, arg0, arg1, proc);\n            final Class<?>[] paramTypes = method.getParameterTypes();\n            Object cArg0 = arg0.toJava(paramTypes[0]);\n            Object cArg1 = arg1.toJava(paramTypes[1]);\n            Object cArg2 = proc.toJava(paramTypes[2]);\n\n            return method.invokeStaticDirect(context, cArg0, cArg1, cArg2);\n\n        }\n        return call(context, self, clazz, name, arg0, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1, IRubyObject arg2, Block block) {\n        if (block.isGiven()) {\n            RubyProc proc = RubyProc.newProc(context.runtime, block, block.type);\n            JavaMethod method = (JavaMethod) findCallableArityFour(self, name, arg0, arg1, arg2, proc);\n            final Class<?>[] paramTypes = method.getParameterTypes();\n            Object cArg0 = arg0.toJava(paramTypes[0]);\n            Object cArg1 = arg1.toJava(paramTypes[1]);\n            Object cArg2 = arg2.toJava(paramTypes[2]);\n            Object cArg3 = proc.toJava(paramTypes[3]);\n\n            return method.invokeStaticDirect(context, cArg0, cArg1, cArg2, cArg3);\n        }\n        return call(context, self, clazz, name, arg0, arg1, arg2);\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/DivCallSite.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/CmpCallSite.java",
                "SLOC": "96",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class CmpCallSite extends BimorphicCallSite {\n\n    public CmpCallSite() {\n        super(\"<=>\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_cmp(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_cmp(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_cmp(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_cmp(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_cmp(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_cmp(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            }
        ],
        "SLOC": "91",
        "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class DivCallSite extends BimorphicCallSite {\n\n    public DivCallSite() {\n        super(\"/\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_div(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_div(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_div(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_div(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_div(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/EqCallSite.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/DivCallSite.java",
                "SLOC": "91",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class DivCallSite extends BimorphicCallSite {\n\n    public DivCallSite() {\n        super(\"/\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_div(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_div(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_div(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_div(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_div(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            }
        ],
        "SLOC": "96",
        "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class EqCallSite extends BimorphicCallSite {\n\n    public EqCallSite() {\n        super(\"==\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_equal(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_equal(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_equal(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_equal(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_equal(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_equal(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/GeCallSite.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/CmpCallSite.java",
                "SLOC": "96",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class CmpCallSite extends BimorphicCallSite {\n\n    public CmpCallSite() {\n        super(\"<=>\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_cmp(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_cmp(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_cmp(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_cmp(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_cmp(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_cmp(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/EqCallSite.java",
                "SLOC": "96",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class EqCallSite extends BimorphicCallSite {\n\n    public EqCallSite() {\n        super(\"==\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_equal(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_equal(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_equal(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_equal(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_equal(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_equal(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            }
        ],
        "SLOC": "91",
        "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class GeCallSite extends BimorphicCallSite {\n\n    public GeCallSite() {\n        super(\">=\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_ge(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_ge(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_ge(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_ge(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_ge(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n    \n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/GtCallSite.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/CmpCallSite.java",
                "SLOC": "96",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class CmpCallSite extends BimorphicCallSite {\n\n    public CmpCallSite() {\n        super(\"<=>\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_cmp(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_cmp(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_cmp(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_cmp(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_cmp(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_cmp(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/EqCallSite.java",
                "SLOC": "96",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class EqCallSite extends BimorphicCallSite {\n\n    public EqCallSite() {\n        super(\"==\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_equal(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_equal(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_equal(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_equal(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_equal(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_equal(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            }
        ],
        "SLOC": "91",
        "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class GtCallSite extends BimorphicCallSite {\n\n    public GtCallSite() {\n        super(\">\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_gt(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_gt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_gt(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_gt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_gt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/LeCallSite.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/CmpCallSite.java",
                "SLOC": "96",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class CmpCallSite extends BimorphicCallSite {\n\n    public CmpCallSite() {\n        super(\"<=>\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_cmp(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_cmp(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_cmp(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_cmp(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_cmp(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_cmp(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/EqCallSite.java",
                "SLOC": "96",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class EqCallSite extends BimorphicCallSite {\n\n    public EqCallSite() {\n        super(\"==\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_equal(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_equal(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_equal(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_equal(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_equal(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_equal(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            }
        ],
        "SLOC": "91",
        "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class LeCallSite extends BimorphicCallSite {\n\n    public LeCallSite() {\n        super(\"<=\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_le(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_le(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_le(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_le(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_le(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/LtCallSite.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/CmpCallSite.java",
                "SLOC": "96",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class CmpCallSite extends BimorphicCallSite {\n\n    public CmpCallSite() {\n        super(\"<=>\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_cmp(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_cmp(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_cmp(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_cmp(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_cmp(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_cmp(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/EqCallSite.java",
                "SLOC": "96",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class EqCallSite extends BimorphicCallSite {\n\n    public EqCallSite() {\n        super(\"==\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_equal(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_equal(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_equal(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_equal(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_equal(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_equal(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            }
        ],
        "SLOC": "91",
        "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class LtCallSite extends BimorphicCallSite {\n\n    public LtCallSite() {\n        super(\"<\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_lt(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_lt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_lt(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_lt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_lt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/MinusCallSite.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/DivCallSite.java",
                "SLOC": "91",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class DivCallSite extends BimorphicCallSite {\n\n    public DivCallSite() {\n        super(\"/\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_div(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_div(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_div(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_div(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_div(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/GeCallSite.java",
                "SLOC": "91",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class GeCallSite extends BimorphicCallSite {\n\n    public GeCallSite() {\n        super(\">=\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_ge(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_ge(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_ge(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_ge(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_ge(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n    \n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/GtCallSite.java",
                "SLOC": "91",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class GtCallSite extends BimorphicCallSite {\n\n    public GtCallSite() {\n        super(\">\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_gt(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_gt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_gt(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_gt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_gt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/LeCallSite.java",
                "SLOC": "91",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class LeCallSite extends BimorphicCallSite {\n\n    public LeCallSite() {\n        super(\"<=\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_le(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_le(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_le(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_le(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_le(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/LtCallSite.java",
                "SLOC": "91",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class LtCallSite extends BimorphicCallSite {\n\n    public LtCallSite() {\n        super(\"<\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_lt(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_lt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_lt(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_lt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_lt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            }
        ],
        "SLOC": "96",
        "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class MinusCallSite extends BimorphicCallSite {\n\n    public MinusCallSite() {\n        super(\"-\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_minus(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_minus(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_minus(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_minus(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_minus(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_minus(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/ModCallSite.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/DivCallSite.java",
                "SLOC": "91",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class DivCallSite extends BimorphicCallSite {\n\n    public DivCallSite() {\n        super(\"/\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_div(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_div(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_div(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_div(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_div(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/GeCallSite.java",
                "SLOC": "91",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class GeCallSite extends BimorphicCallSite {\n\n    public GeCallSite() {\n        super(\">=\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_ge(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_ge(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_ge(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_ge(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_ge(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n    \n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/GtCallSite.java",
                "SLOC": "91",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class GtCallSite extends BimorphicCallSite {\n\n    public GtCallSite() {\n        super(\">\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_gt(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_gt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_gt(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_gt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_gt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/LeCallSite.java",
                "SLOC": "91",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class LeCallSite extends BimorphicCallSite {\n\n    public LeCallSite() {\n        super(\"<=\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_le(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_le(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_le(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_le(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_le(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/LtCallSite.java",
                "SLOC": "91",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class LtCallSite extends BimorphicCallSite {\n\n    public LtCallSite() {\n        super(\"<\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_lt(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_lt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_lt(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_lt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_lt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            }
        ],
        "SLOC": "86",
        "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class ModCallSite extends BimorphicCallSite {\n\n    public ModCallSite() {\n        super(\"%\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_mod(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_mod(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_mod(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_mod(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/MulCallSite.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/DivCallSite.java",
                "SLOC": "91",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class DivCallSite extends BimorphicCallSite {\n\n    public DivCallSite() {\n        super(\"/\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_div(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_div(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_div(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_div(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_div(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/GeCallSite.java",
                "SLOC": "91",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class GeCallSite extends BimorphicCallSite {\n\n    public GeCallSite() {\n        super(\">=\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_ge(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_ge(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_ge(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_ge(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_ge(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n    \n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/GtCallSite.java",
                "SLOC": "91",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class GtCallSite extends BimorphicCallSite {\n\n    public GtCallSite() {\n        super(\">\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_gt(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_gt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_gt(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_gt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_gt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/LeCallSite.java",
                "SLOC": "91",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class LeCallSite extends BimorphicCallSite {\n\n    public LeCallSite() {\n        super(\"<=\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_le(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_le(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_le(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_le(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_le(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/LtCallSite.java",
                "SLOC": "91",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class LtCallSite extends BimorphicCallSite {\n\n    public LtCallSite() {\n        super(\"<\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_lt(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_lt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_lt(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_lt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_lt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            }
        ],
        "SLOC": "96",
        "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class MulCallSite extends BimorphicCallSite {\n\n    public MulCallSite() {\n        super(\"*\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_mul(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_mul(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_mul(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_mul(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_mul(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_mul(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/PlusCallSite.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/DivCallSite.java",
                "SLOC": "91",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class DivCallSite extends BimorphicCallSite {\n\n    public DivCallSite() {\n        super(\"/\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_div(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_div(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_div(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_div(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_div(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/GeCallSite.java",
                "SLOC": "91",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class GeCallSite extends BimorphicCallSite {\n\n    public GeCallSite() {\n        super(\">=\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_ge(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_ge(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_ge(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_ge(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_ge(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n    \n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/GtCallSite.java",
                "SLOC": "91",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class GtCallSite extends BimorphicCallSite {\n\n    public GtCallSite() {\n        super(\">\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_gt(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_gt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_gt(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_gt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_gt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/LeCallSite.java",
                "SLOC": "91",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class LeCallSite extends BimorphicCallSite {\n\n    public LeCallSite() {\n        super(\"<=\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_le(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_le(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_le(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_le(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_le(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/LtCallSite.java",
                "SLOC": "91",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class LtCallSite extends BimorphicCallSite {\n\n    public LtCallSite() {\n        super(\"<\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_lt(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_lt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_lt(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_lt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_lt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            }
        ],
        "SLOC": "96",
        "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class PlusCallSite extends BimorphicCallSite {\n\n    public PlusCallSite() {\n        super(\"+\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_plus(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_plus(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_plus(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_plus(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_plus(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_plus(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/ArgsCatNode.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/AndNode.java",
                "SLOC": "72",
                "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2001-2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2001-2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/** \n * Represents a && (and) operator.\n */\npublic class AndNode extends Node implements BinaryOperatorNode {\n    private final Node firstNode;\n    private final Node secondNode;\n\n    public AndNode(ISourcePosition position, Node firstNode, Node secondNode) {\n        super(position, firstNode.containsVariableAssignment() || secondNode.containsVariableAssignment());\n        \n        assert firstNode != null : \"AndNode.first == null\";\n        assert secondNode != null : \"AndNode.second == null\";\n        \n        this.firstNode = firstNode;\n        this.secondNode = secondNode;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.ANDNODE;\n    }\n\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitAndNode(this);\n    }\n\n    /**\n     * Gets the secondNode.\n     * @return Returns a Node\n     */\n    public Node getSecondNode() {\n        return secondNode;\n    }\n\n    /**\n     * Gets the firstNode.\n     * @return Returns a Node\n     */\n    public Node getFirstNode() {\n        return firstNode;\n    }\n    \n    public List<Node> childNodes() {\n        return Node.createList(firstNode, secondNode);\n    }\n}\n"
            }
        ],
        "SLOC": "61",
        "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2001-2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2001-2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * Copyright (C) 2004 Stefan Matthias Aust <sma@3plus4.de>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\npublic class ArgsCatNode extends Node {\n\tprivate final Node firstNode;\n    private final Node secondNode;\n\n    public ArgsCatNode(ISourcePosition position, Node firstNode, Node secondNode) {\n        super(position, firstNode.containsVariableAssignment() || secondNode.containsVariableAssignment());\n\n        assert firstNode != null : \"ArgsCatNode.first == null\";\n        assert secondNode != null : \"ArgsCatNode.second == null\";\n\n        this.firstNode = firstNode;\n        this.secondNode = secondNode;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.ARGSCATNODE;\n    }\n\n    public <T> T accept(NodeVisitor<T> visitor) {\n        return visitor.visitArgsCatNode(this);\n    }\n\n    public Node getFirstNode() {\n        return firstNode;\n    }\n\n    public Node getSecondNode() {\n        return secondNode;\n    }\n\n    public List<Node> childNodes() {\n        return Node.createList(firstNode, secondNode);\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/ClassVarDeclNode.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/ClassVarAsgnNode.java",
                "SLOC": "75",
                "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.RubySymbol;\nimport org.jruby.ast.types.INameNode;\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/**\n * Class variable assignment node.\n */\npublic class ClassVarAsgnNode extends AssignableNode implements INameNode {\n    private RubySymbol name;\n\n    /**\n     * @param name id of the class variable to assign to\n     * @param valueNode  Node used to compute the new value when the assignment is evaled\n     */\n    public ClassVarAsgnNode(ISourcePosition position, RubySymbol name, Node valueNode) {\n        super(position, valueNode, valueNode != null && valueNode.containsVariableAssignment());\n        \n        this.name = name;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.CLASSVARASGNNODE;\n    }\n\n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitClassVarAsgnNode(this);\n    }\n\n    /**\n     * Gets the name.\n     * @return Returns a String\n     */\n    public RubySymbol getName() {\n        return name;\n    }\n\n    public List<Node> childNodes() {\n        return createList(getValueNode());\n    }\n\n    @Override\n    public boolean needsDefinitionCheck() {\n        return false;\n    }\n}\n"
            }
        ],
        "SLOC": "73",
        "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * Copyright (C) 2004 Stefan Matthias Aust <sma@3plus4.de>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.RubySymbol;\nimport org.jruby.ast.types.INameNode;\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/**\n * Class variable declaration.\n */\n@Deprecated\npublic class ClassVarDeclNode extends AssignableNode implements INameNode {\n    private RubySymbol name;\n\n    public ClassVarDeclNode(ISourcePosition position, RubySymbol name, Node valueNode) {\n        super(position, valueNode, valueNode != null && valueNode.containsVariableAssignment());\n\n        this.name = name;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.CLASSVARDECLNODE;\n    }\n    \n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitClassVarDeclNode(this);\n    }\n\n    /**\n     * Gets the name.\n     * @return Returns a String\n     */\n    public RubySymbol getName() {\n        return name;\n    }\n    \n    public List<Node> childNodes() {\n        return createList(getValueNode());\n    }\n\n    @Override\n    public boolean needsDefinitionCheck() {\n        return false;\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/ConstNode.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/ClassVarNode.java",
                "SLOC": "67",
                "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2002 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.RubySymbol;\nimport org.jruby.ast.types.INameNode;\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/**\n * Access to a class variable.\n */\npublic class ClassVarNode extends Node implements INameNode, SideEffectFree {\n    private RubySymbol name;\n\n    public ClassVarNode(ISourcePosition position, RubySymbol name) {\n        super(position, false);\n        this.name = name;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.CLASSVARNODE;\n    }\n\n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitClassVarNode(this);\n    }\n\n    /**\n     * Gets the name.\n     * @return Returns a String\n     */\n    public RubySymbol getName() {\n        return name;\n    }\n    \n    public List<Node> childNodes() {\n        return EMPTY_LIST;\n    }\n}\n"
            }
        ],
        "SLOC": "67",
        "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2001-2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2001-2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.RubySymbol;\nimport org.jruby.ast.types.INameNode;\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/**\n * The access to a Constant.\n */\npublic class ConstNode extends Node implements INameNode {\n    private RubySymbol name;\n\n    public ConstNode(ISourcePosition position, RubySymbol name) {\n        super(position, false);\n        this.name = name;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.CONSTNODE;\n    }\n    \n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitConstNode(this);\n    }\n\n    /**\n     * Gets the name.\n     * @return Returns a String\n     */\n    public RubySymbol getName() {\n        return name;\n    }\n    \n    public List<Node> childNodes() {\n        return EMPTY_LIST;\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/DVarNode.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/DAsgnNode.java",
                "SLOC": "93",
                "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2001-2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2001-2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2004-2006 Thomas E Enebo <enebo@acm.org>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.RubySymbol;\nimport org.jruby.ast.types.INameNode;\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/**\n * An assignment to a dynamic variable (e.g. block scope local variable).\n */\npublic class DAsgnNode extends AssignableNode implements INameNode, IScopedNode {\n    // The name of the variable\n    private RubySymbol name;\n    \n    // A scoped location of this variable (high 16 bits is how many scopes down and low 16 bits\n    // is what index in the right scope to set the value.\n    private int location;\n\n    public DAsgnNode(ISourcePosition position, RubySymbol name, int location, Node valueNode) {\n        super(position, valueNode, true);\n        this.name = name;\n        this.location = location;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.DASGNNODE;\n    }\n    \n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitDAsgnNode(this);\n    }\n    \n    /**\n     * Gets the name.\n     * @return Returns a String\n     */\n    public RubySymbol getName() {\n        return name;\n    }\n\n    /**\n     * How many scopes should we burrow down to until we need to set the block variable value.\n     * \n     * @return 0 for current scope, 1 for one down, ...\n     */\n    public int getDepth() {\n        return location >> 16;\n    }\n    \n    /**\n     * Gets the index within the scope construct that actually holds the eval'd value\n     * of this local variable\n     * \n     * @return Returns an int offset into storage structure\n     */\n    public int getIndex() {\n        return location & 0xffff;\n    }\n    \n    public List<Node> childNodes() {\n        return createList(getValueNode());\n    }\n\n    @Override\n    public boolean needsDefinitionCheck() {\n        return false;\n    }\n}\n"
            }
        ],
        "SLOC": "93",
        "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2001-2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2001-2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2002 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2004-2006 Thomas E Enebo <enebo@acm.org>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.RubySymbol;\nimport org.jruby.ast.types.INameNode;\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/**\n * Access a dynamic variable (e.g. block scope local variable).\n */\npublic class DVarNode extends Node implements INameNode, IScopedNode, SideEffectFree {\n    // The name of the variable\n    private RubySymbol name;\n    \n    // A scoped location of this variable (high 16 bits is how many scopes down and low 16 bits\n    // is what index in the right scope to set the value.\n    private int location;\n\n    public DVarNode(ISourcePosition position, int location, RubySymbol name) {\n        super(position, false);\n        this.location = location;\n        this.name = name;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.DVARNODE;\n    }\n    \n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitDVarNode(this);\n    }\n    \n    /**\n     * How many scopes should we burrow down to until we need to set the block variable value.\n     * \n     * @return 0 for current scope, 1 for one down, ...\n     */\n    public int getDepth() {\n        return location >> 16;\n    }\n    \n    /**\n     * Gets the index within the scope construct that actually holds the eval'd value\n     * of this local variable\n     * \n     * @return Returns an int offset into storage structure\n     */\n    public int getIndex() {\n        return location & 0xffff;\n    }\n\n    /**\n     * Gets the name.\n     * @return Returns a String\n     */\n    public RubySymbol getName() {\n        return name;\n    }\n    \n    public List<Node> childNodes() {\n        return EMPTY_LIST;\n    }\n\n    @Override\n    public boolean needsDefinitionCheck() {\n        return false;\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/FloatNode.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/FixnumNode.java",
                "SLOC": "69",
                "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.ast.types.ILiteralNode;\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/** \n * Represents an integer literal.\n */\npublic class FixnumNode extends NumericNode implements ILiteralNode, SideEffectFree {\n    private long value;\n\n    public FixnumNode(ISourcePosition position, long value) {\n        super(position);\n        this.value = value;\n    }\n\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitFixnumNode(this);\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.FIXNUMNODE;\n    }\n\n    @Override\n    public NumericNode negate() {\n        return new FixnumNode(getPosition(), -value);\n    }\n\n    /**\n     * Gets the value.\n     * @return Returns a long\n     */\n    public long getValue() {\n        return value;\n    }\n\n    public void setValue(long value) {\n        this.value = value;\n    }\n\n    public List<Node> childNodes() {\n        return EMPTY_LIST;\n    }\n}\n"
            }
        ],
        "SLOC": "73",
        "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2002 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.ast.types.ILiteralNode;\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/** \n * Represents a float literal.\n */\npublic class FloatNode extends NumericNode implements ILiteralNode, SideEffectFree {\n    private double value;\n\n    public FloatNode(ISourcePosition position, double value) {\n        super(position);\n        this.value = value;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.FLOATNODE;\n    }\n\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitFloatNode(this);\n    }\n\n    @Override\n    public NumericNode negate() {\n        return new FloatNode(getPosition(), -value);\n    }\n\n    /**\n     * Gets the value.\n     * @return Returns a double\n     */\n    public double getValue() {\n        return value;\n    }\n    \n    /**\n     * Sets the value\n     * @param value to set\n     */\n    public void setValue(double value) {\n        this.value = value;\n    }\n\n    \n    public List<Node> childNodes() {\n        return EMPTY_LIST;\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/GlobalAsgnNode.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/ClassVarDeclNode.java",
                "SLOC": "73",
                "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * Copyright (C) 2004 Stefan Matthias Aust <sma@3plus4.de>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.RubySymbol;\nimport org.jruby.ast.types.INameNode;\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/**\n * Class variable declaration.\n */\n@Deprecated\npublic class ClassVarDeclNode extends AssignableNode implements INameNode {\n    private RubySymbol name;\n\n    public ClassVarDeclNode(ISourcePosition position, RubySymbol name, Node valueNode) {\n        super(position, valueNode, valueNode != null && valueNode.containsVariableAssignment());\n\n        this.name = name;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.CLASSVARDECLNODE;\n    }\n    \n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitClassVarDeclNode(this);\n    }\n\n    /**\n     * Gets the name.\n     * @return Returns a String\n     */\n    public RubySymbol getName() {\n        return name;\n    }\n    \n    public List<Node> childNodes() {\n        return createList(getValueNode());\n    }\n\n    @Override\n    public boolean needsDefinitionCheck() {\n        return false;\n    }\n}\n"
            }
        ],
        "SLOC": "74",
        "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2004 Charles O Nutter <headius@headius.com>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * Copyright (C) 2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2004 Stefan Matthias Aust <sma@3plus4.de>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.RubySymbol;\nimport org.jruby.ast.types.INameNode;\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/**\n * Represents an assignment to a global variable.\n */\npublic class GlobalAsgnNode extends AssignableNode implements INameNode {\n    private RubySymbol name;\n\n    public GlobalAsgnNode(ISourcePosition position, RubySymbol name, Node valueNode) {\n        super(position, valueNode, valueNode != null && valueNode.containsVariableAssignment());\n\n        this.name = name;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.GLOBALASGNNODE;\n    }\n    \n    /**\n     * RubyMethod used by visitors.\n     * accepts the visitor \n     * @param iVisitor the visitor to accept\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitGlobalAsgnNode(this);\n    }\n    /**\n     * Gets the name.\n     * @return Returns a String\n     */\n    public RubySymbol getName() {\n        return name;\n    }\n    \n    public List<Node> childNodes() {\n        return createList(getValueNode());\n    }\n\n    @Override\n    public boolean needsDefinitionCheck() {\n        return false;\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/GlobalVarNode.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/ConstNode.java",
                "SLOC": "67",
                "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2001-2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2001-2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.RubySymbol;\nimport org.jruby.ast.types.INameNode;\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/**\n * The access to a Constant.\n */\npublic class ConstNode extends Node implements INameNode {\n    private RubySymbol name;\n\n    public ConstNode(ISourcePosition position, RubySymbol name) {\n        super(position, false);\n        this.name = name;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.CONSTNODE;\n    }\n    \n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitConstNode(this);\n    }\n\n    /**\n     * Gets the name.\n     * @return Returns a String\n     */\n    public RubySymbol getName() {\n        return name;\n    }\n    \n    public List<Node> childNodes() {\n        return EMPTY_LIST;\n    }\n}\n"
            }
        ],
        "SLOC": "67",
        "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2002 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.RubySymbol;\nimport org.jruby.ast.types.INameNode;\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/**\n *\taccess to a global variable.\n */\npublic class GlobalVarNode extends Node implements INameNode, SideEffectFree {\n    private RubySymbol name;\n\n    public GlobalVarNode(ISourcePosition position, RubySymbol name) {\n        super(position, false);\n        this.name = name;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.GLOBALVARNODE;\n    }\n    \n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitGlobalVarNode(this);\n    }\n\n    /**\n     * Gets the name.\n     * @return Returns a String\n     */\n    public RubySymbol getName() {\n        return name;\n    }\n\n    public List<Node> childNodes() {\n        return EMPTY_LIST;\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/InstVarNode.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/ConstNode.java",
                "SLOC": "67",
                "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2001-2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2001-2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.RubySymbol;\nimport org.jruby.ast.types.INameNode;\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/**\n * The access to a Constant.\n */\npublic class ConstNode extends Node implements INameNode {\n    private RubySymbol name;\n\n    public ConstNode(ISourcePosition position, RubySymbol name) {\n        super(position, false);\n        this.name = name;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.CONSTNODE;\n    }\n    \n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitConstNode(this);\n    }\n\n    /**\n     * Gets the name.\n     * @return Returns a String\n     */\n    public RubySymbol getName() {\n        return name;\n    }\n    \n    public List<Node> childNodes() {\n        return EMPTY_LIST;\n    }\n}\n"
            }
        ],
        "SLOC": "68",
        "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2002 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * Copyright (C) 2006 Lukas Felber <lfelber@hsr.ch>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.RubySymbol;\nimport org.jruby.ast.types.INameNode;\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/** \n * Represents an instance variable accessor.\n */\npublic class InstVarNode extends Node implements INameNode, SideEffectFree {\n    private RubySymbol name;\n\n    public InstVarNode(ISourcePosition position, RubySymbol name) {\n        super(position, false);\n        this.name = name;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.INSTVARNODE;\n    }\n    \n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitInstVarNode(this);\n    }\n\t\n    /**\n     * Gets the name.\n     * @return Returns a String\n     */\n    public RubySymbol getName() {\n        return name;\n    }\n\n    public List<Node> childNodes() {\n        return EMPTY_LIST;\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/LocalAsgnNode.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/DVarNode.java",
                "SLOC": "93",
                "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2001-2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2001-2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2002 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2004-2006 Thomas E Enebo <enebo@acm.org>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.RubySymbol;\nimport org.jruby.ast.types.INameNode;\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/**\n * Access a dynamic variable (e.g. block scope local variable).\n */\npublic class DVarNode extends Node implements INameNode, IScopedNode, SideEffectFree {\n    // The name of the variable\n    private RubySymbol name;\n    \n    // A scoped location of this variable (high 16 bits is how many scopes down and low 16 bits\n    // is what index in the right scope to set the value.\n    private int location;\n\n    public DVarNode(ISourcePosition position, int location, RubySymbol name) {\n        super(position, false);\n        this.location = location;\n        this.name = name;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.DVARNODE;\n    }\n    \n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitDVarNode(this);\n    }\n    \n    /**\n     * How many scopes should we burrow down to until we need to set the block variable value.\n     * \n     * @return 0 for current scope, 1 for one down, ...\n     */\n    public int getDepth() {\n        return location >> 16;\n    }\n    \n    /**\n     * Gets the index within the scope construct that actually holds the eval'd value\n     * of this local variable\n     * \n     * @return Returns an int offset into storage structure\n     */\n    public int getIndex() {\n        return location & 0xffff;\n    }\n\n    /**\n     * Gets the name.\n     * @return Returns a String\n     */\n    public RubySymbol getName() {\n        return name;\n    }\n    \n    public List<Node> childNodes() {\n        return EMPTY_LIST;\n    }\n\n    @Override\n    public boolean needsDefinitionCheck() {\n        return false;\n    }\n}\n"
            }
        ],
        "SLOC": "93",
        "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * Copyright (C) 2004 Stefan Matthias Aust <sma@3plus4.de>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.RubySymbol;\nimport org.jruby.ast.types.INameNode;\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/**\n * An assignment to a local variable.\n */\npublic class LocalAsgnNode extends AssignableNode implements INameNode, IScopedNode {\n    // The name of the variable\n    private RubySymbol name;\n    \n    // A scoped location of this variable (high 16 bits is how many scopes down and low 16 bits\n    // is what index in the right scope to set the value.\n    private final int location;\n\n    public LocalAsgnNode(ISourcePosition position, RubySymbol name, int location, Node valueNode) {\n        super(position, valueNode, true);\n        this.name = name;\n        this.location = location;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.LOCALASGNNODE;\n    }\n    \n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitLocalAsgnNode(this);\n    }\n    \n    /**\n     * Name of the local assignment.\n     **/\n    public RubySymbol getName() {\n        return name;\n    }\n\n    /**\n     * How many scopes should we burrow down to until we need to set the block variable value.\n     * \n     * @return 0 for current scope, 1 for one down, ...\n     */\n    public int getDepth() {\n        return location >> 16;\n    }\n    \n    /**\n     * Gets the index within the scope construct that actually holds the eval'd value\n     * of this local variable\n     * \n     * @return Returns an int offset into storage structure\n     */\n    public int getIndex() {\n        return location & 0xffff;\n    }\n    \n    public List<Node> childNodes() {\n        return createList(getValueNode());\n    }\n\n    @Override\n    public boolean needsDefinitionCheck() {\n        return false;\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/LocalVarNode.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/DAsgnNode.java",
                "SLOC": "93",
                "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2001-2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2001-2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2004-2006 Thomas E Enebo <enebo@acm.org>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.RubySymbol;\nimport org.jruby.ast.types.INameNode;\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/**\n * An assignment to a dynamic variable (e.g. block scope local variable).\n */\npublic class DAsgnNode extends AssignableNode implements INameNode, IScopedNode {\n    // The name of the variable\n    private RubySymbol name;\n    \n    // A scoped location of this variable (high 16 bits is how many scopes down and low 16 bits\n    // is what index in the right scope to set the value.\n    private int location;\n\n    public DAsgnNode(ISourcePosition position, RubySymbol name, int location, Node valueNode) {\n        super(position, valueNode, true);\n        this.name = name;\n        this.location = location;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.DASGNNODE;\n    }\n    \n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitDAsgnNode(this);\n    }\n    \n    /**\n     * Gets the name.\n     * @return Returns a String\n     */\n    public RubySymbol getName() {\n        return name;\n    }\n\n    /**\n     * How many scopes should we burrow down to until we need to set the block variable value.\n     * \n     * @return 0 for current scope, 1 for one down, ...\n     */\n    public int getDepth() {\n        return location >> 16;\n    }\n    \n    /**\n     * Gets the index within the scope construct that actually holds the eval'd value\n     * of this local variable\n     * \n     * @return Returns an int offset into storage structure\n     */\n    public int getIndex() {\n        return location & 0xffff;\n    }\n    \n    public List<Node> childNodes() {\n        return createList(getValueNode());\n    }\n\n    @Override\n    public boolean needsDefinitionCheck() {\n        return false;\n    }\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/LocalAsgnNode.java",
                "SLOC": "93",
                "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * Copyright (C) 2004 Stefan Matthias Aust <sma@3plus4.de>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.RubySymbol;\nimport org.jruby.ast.types.INameNode;\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/**\n * An assignment to a local variable.\n */\npublic class LocalAsgnNode extends AssignableNode implements INameNode, IScopedNode {\n    // The name of the variable\n    private RubySymbol name;\n    \n    // A scoped location of this variable (high 16 bits is how many scopes down and low 16 bits\n    // is what index in the right scope to set the value.\n    private final int location;\n\n    public LocalAsgnNode(ISourcePosition position, RubySymbol name, int location, Node valueNode) {\n        super(position, valueNode, true);\n        this.name = name;\n        this.location = location;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.LOCALASGNNODE;\n    }\n    \n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitLocalAsgnNode(this);\n    }\n    \n    /**\n     * Name of the local assignment.\n     **/\n    public RubySymbol getName() {\n        return name;\n    }\n\n    /**\n     * How many scopes should we burrow down to until we need to set the block variable value.\n     * \n     * @return 0 for current scope, 1 for one down, ...\n     */\n    public int getDepth() {\n        return location >> 16;\n    }\n    \n    /**\n     * Gets the index within the scope construct that actually holds the eval'd value\n     * of this local variable\n     * \n     * @return Returns an int offset into storage structure\n     */\n    public int getIndex() {\n        return location & 0xffff;\n    }\n    \n    public List<Node> childNodes() {\n        return createList(getValueNode());\n    }\n\n    @Override\n    public boolean needsDefinitionCheck() {\n        return false;\n    }\n}\n"
            }
        ],
        "SLOC": "94",
        "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2002 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2004-2006 Thomas E Enebo <enebo@acm.org>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.RubySymbol;\nimport org.jruby.ast.types.INameNode;\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/**\n * Access a local variable \n */\npublic class LocalVarNode extends Node implements INameNode, IScopedNode, SideEffectFree {\n    // The name of the variable\n    private RubySymbol name;\n    \n    // A scoped location of this variable (high 16 bits is how many scopes down and low 16 bits\n    // is what index in the right scope to set the value.\n    private final int location;\n\n    public LocalVarNode(ISourcePosition position, int location, RubySymbol name) {\n        super(position, false);\n        this.location = location;\n        this.name = name;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.LOCALVARNODE;\n    }\n\n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitLocalVarNode(this);\n    }\n\n    /**\n     * How many scopes should we burrow down to until we need to set the block variable value.\n     * \n     * @return 0 for current scope, 1 for one down, ...\n     */\n    public int getDepth() {\n        return location >> 16;\n    }\n    \n    /**\n     * Gets the index within the scope construct that actually holds the eval'd value\n     * of this local variable\n     * \n     * @return Returns an int offset into storage structure\n     */\n    public int getIndex() {\n        return location & 0xffff;\n    }\n\n    /**\n     * What is the name of this variable\n     * \n     * @return the name of the variable\n     */\n    public RubySymbol getName() {\n        return name;\n    }\n    \n    public List<Node> childNodes() {\n        return EMPTY_LIST;\n    }\n\n    @Override\n    public boolean needsDefinitionCheck() {\n        return false;\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/NextNode.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/BreakNode.java",
                "SLOC": "69",
                "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2001-2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2001-2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * Copyright (C) 2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/**\n * Represents a 'break' statement.\n */\npublic class BreakNode extends Node implements NonLocalControlFlowNode {\n    private final Node valueNode;\n    \n    public BreakNode(ISourcePosition position, Node valueNode) {\n        super(position, valueNode != null && valueNode.containsVariableAssignment());\n        \n        assert valueNode != null : \"valueNode is not null\";\n        \n        this.valueNode = valueNode;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.BREAKNODE;\n    }\n\n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitBreakNode(this);\n    }\n    \n    /**\n     * Gets the valueNode.\n     * @return Returns a Node\n     */\n    public Node getValueNode() {\n        return valueNode;\n    }\n\n    public boolean hasValue() {\n        return valueNode != NilImplicitNode.NIL;\n    }\n    \n    public List<Node> childNodes() {\n        return createList(valueNode);\n    }\n}\n"
            }
        ],
        "SLOC": "69",
        "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2001-2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2001-2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2002 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/** \n * Represents a 'next' statement.\n */\npublic class NextNode extends Node implements NonLocalControlFlowNode {\n    private final Node valueNode;\n\n    public NextNode(ISourcePosition position, Node valueNode) {\n        super(position, valueNode.containsVariableAssignment());\n        \n        assert valueNode != null : \"valueNode is not null\";\n        \n        this.valueNode = valueNode;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.NEXTNODE;\n    }\n    \n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitNextNode(this);\n    }\n    \n    /**\n     * Gets the valueNode.\n     * @return Returns a Node\n     */\n    public Node getValueNode() {\n        return valueNode;\n    }\n\n    public boolean hasValue() {\n        return valueNode != NilImplicitNode.NIL;\n    }\n    \n    public List<Node> childNodes() {\n        return createList(valueNode);\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/OrNode.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/AndNode.java",
                "SLOC": "72",
                "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2001-2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2001-2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/** \n * Represents a && (and) operator.\n */\npublic class AndNode extends Node implements BinaryOperatorNode {\n    private final Node firstNode;\n    private final Node secondNode;\n\n    public AndNode(ISourcePosition position, Node firstNode, Node secondNode) {\n        super(position, firstNode.containsVariableAssignment() || secondNode.containsVariableAssignment());\n        \n        assert firstNode != null : \"AndNode.first == null\";\n        assert secondNode != null : \"AndNode.second == null\";\n        \n        this.firstNode = firstNode;\n        this.secondNode = secondNode;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.ANDNODE;\n    }\n\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitAndNode(this);\n    }\n\n    /**\n     * Gets the secondNode.\n     * @return Returns a Node\n     */\n    public Node getSecondNode() {\n        return secondNode;\n    }\n\n    /**\n     * Gets the firstNode.\n     * @return Returns a Node\n     */\n    public Node getFirstNode() {\n        return firstNode;\n    }\n    \n    public List<Node> childNodes() {\n        return Node.createList(firstNode, secondNode);\n    }\n}\n"
            }
        ],
        "SLOC": "76",
        "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2001-2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2001-2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/**\n * represents '||' (or) statements\n */\npublic class OrNode extends Node implements BinaryOperatorNode {\n    private final Node firstNode;\n    private final Node secondNode;\n\n    public OrNode(ISourcePosition position, Node firstNode, Node secondNode) {\n        super(position, firstNode.containsVariableAssignment() || secondNode.containsVariableAssignment());\n        \n        assert firstNode != null : \"firstNode is not null\";\n        assert secondNode != null : \"secondNode is not null\";\n        \n        this.firstNode = firstNode;\n        this.secondNode = secondNode;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.ORNODE;\n    }\n\n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitOrNode(this);\n    }\n\n    /**\n     * Gets the firstNode.\n     * @return Returns a Node\n     */\n    public Node getFirstNode() {\n        return firstNode;\n    }\n\n    /**\n     * Gets the secondNode.\n     * @return Returns a Node\n     */\n    public Node getSecondNode() {\n        return secondNode;\n    }\n\n    public List<Node> childNodes() {\n        return Node.createList(firstNode, secondNode);\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/RetryNode.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/RedoNode.java",
                "SLOC": "62",
                "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2001-2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2001-2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * Copyright (C) 2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/**\n * Represents a 'redo'\n */\npublic class RedoNode extends Node implements NonLocalControlFlowNode {\n    public RedoNode(ISourcePosition position) {\n        super(position, false);\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.REDONODE;\n    }\n\n    public Node getValueNode() {\n        return null; // Needed for non local control flow node marker\n    }\n\n    public boolean hasValue() {\n        return false; // Redo never allows a value\n    }\n\n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitRedoNode(this);\n    }\n    \n    public List<Node> childNodes() {\n        return EMPTY_LIST;\n    }\n}\n"
            }
        ],
        "SLOC": "61",
        "content": "/***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2001-2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2001-2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * Copyright (C) 2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/** \n * Represents a 'retry' statement.\n */\npublic class RetryNode extends Node implements NonLocalControlFlowNode {\n    public RetryNode(ISourcePosition position) {\n        super(position, false);\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.RETRYNODE;\n    }\n\n    public Node getValueNode() {\n        return null; // Needed for non local control flow node marker\n    }\n\n    public boolean hasValue() {\n        return false; // Retry never allows a value\n    }\n\n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitRetryNode(this);\n    }\n    \n    public List<Node> childNodes() {\n        return EMPTY_LIST;\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/ReturnNode.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/BreakNode.java",
                "SLOC": "69",
                "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2001-2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2001-2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * Copyright (C) 2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/**\n * Represents a 'break' statement.\n */\npublic class BreakNode extends Node implements NonLocalControlFlowNode {\n    private final Node valueNode;\n    \n    public BreakNode(ISourcePosition position, Node valueNode) {\n        super(position, valueNode != null && valueNode.containsVariableAssignment());\n        \n        assert valueNode != null : \"valueNode is not null\";\n        \n        this.valueNode = valueNode;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.BREAKNODE;\n    }\n\n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitBreakNode(this);\n    }\n    \n    /**\n     * Gets the valueNode.\n     * @return Returns a Node\n     */\n    public Node getValueNode() {\n        return valueNode;\n    }\n\n    public boolean hasValue() {\n        return valueNode != NilImplicitNode.NIL;\n    }\n    \n    public List<Node> childNodes() {\n        return createList(valueNode);\n    }\n}\n"
            }
        ],
        "SLOC": "65",
        "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2001-2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2001-2004 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2002 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/** \n * Represents a return statement.\n */\npublic class ReturnNode extends Node implements NonLocalControlFlowNode {\n    private final Node valueNode;\n\n    public ReturnNode(ISourcePosition position, Node valueNode) {\n        super(position, valueNode.containsVariableAssignment());\n        \n        assert valueNode != null : \"valueNode is not null\";\n        \n        this.valueNode = valueNode;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.RETURNNODE;\n    }\n\n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitReturnNode(this);\n    }\n\n    public Node getValueNode() {\n        return valueNode;\n    }\n\n    public boolean hasValue() {\n        return valueNode != NilImplicitNode.NIL;\n    }\n    \n    public List<Node> childNodes() {\n        return createList(valueNode);\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/VCallNode.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/ClassVarNode.java",
                "SLOC": "67",
                "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2002 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.RubySymbol;\nimport org.jruby.ast.types.INameNode;\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/**\n * Access to a class variable.\n */\npublic class ClassVarNode extends Node implements INameNode, SideEffectFree {\n    private RubySymbol name;\n\n    public ClassVarNode(ISourcePosition position, RubySymbol name) {\n        super(position, false);\n        this.name = name;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.CLASSVARNODE;\n    }\n\n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitClassVarNode(this);\n    }\n\n    /**\n     * Gets the name.\n     * @return Returns a String\n     */\n    public RubySymbol getName() {\n        return name;\n    }\n    \n    public List<Node> childNodes() {\n        return EMPTY_LIST;\n    }\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/ConstNode.java",
                "SLOC": "67",
                "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2001-2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2001-2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.RubySymbol;\nimport org.jruby.ast.types.INameNode;\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/**\n * The access to a Constant.\n */\npublic class ConstNode extends Node implements INameNode {\n    private RubySymbol name;\n\n    public ConstNode(ISourcePosition position, RubySymbol name) {\n        super(position, false);\n        this.name = name;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.CONSTNODE;\n    }\n    \n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitConstNode(this);\n    }\n\n    /**\n     * Gets the name.\n     * @return Returns a String\n     */\n    public RubySymbol getName() {\n        return name;\n    }\n    \n    public List<Node> childNodes() {\n        return EMPTY_LIST;\n    }\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/GlobalVarNode.java",
                "SLOC": "67",
                "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2002 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.RubySymbol;\nimport org.jruby.ast.types.INameNode;\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/**\n *\taccess to a global variable.\n */\npublic class GlobalVarNode extends Node implements INameNode, SideEffectFree {\n    private RubySymbol name;\n\n    public GlobalVarNode(ISourcePosition position, RubySymbol name) {\n        super(position, false);\n        this.name = name;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.GLOBALVARNODE;\n    }\n    \n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitGlobalVarNode(this);\n    }\n\n    /**\n     * Gets the name.\n     * @return Returns a String\n     */\n    public RubySymbol getName() {\n        return name;\n    }\n\n    public List<Node> childNodes() {\n        return EMPTY_LIST;\n    }\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/InstVarNode.java",
                "SLOC": "68",
                "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2002 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * Copyright (C) 2006 Lukas Felber <lfelber@hsr.ch>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.RubySymbol;\nimport org.jruby.ast.types.INameNode;\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/** \n * Represents an instance variable accessor.\n */\npublic class InstVarNode extends Node implements INameNode, SideEffectFree {\n    private RubySymbol name;\n\n    public InstVarNode(ISourcePosition position, RubySymbol name) {\n        super(position, false);\n        this.name = name;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.INSTVARNODE;\n    }\n    \n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitInstVarNode(this);\n    }\n\t\n    /**\n     * Gets the name.\n     * @return Returns a String\n     */\n    public RubySymbol getName() {\n        return name;\n    }\n\n    public List<Node> childNodes() {\n        return EMPTY_LIST;\n    }\n}\n"
            }
        ],
        "SLOC": "70",
        "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2001-2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2001-2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2002 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * Copyright (C) 2004 Charles O Nutter <headius@headius.com>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.RubySymbol;\nimport org.jruby.ast.types.INameNode;\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/**\n * RubyMethod call without any arguments\n *\n */\npublic class VCallNode extends Node implements INameNode {\n    private RubySymbol name;\n\n    public VCallNode(ISourcePosition position, RubySymbol name) {\n        super(position, false);\n\n        this.name = name;\n        setNewline();\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.VCALLNODE;\n    }\n    \n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitVCallNode(this);\n    }\n\n    /**\n     * Gets the methodName.\n     * @return Returns a String\n     */\n    public RubySymbol getName() {\n        return name;\n    }\n    \n    public List<Node> childNodes() {\n        return EMPTY_LIST;\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/WhileNode.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/UntilNode.java",
                "SLOC": "88",
                "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2001-2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2001-2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/** \n * Represents an until statement.\n */\npublic class UntilNode extends Node {\n    private final Node conditionNode;\n    private final Node bodyNode;\n    private final boolean evaluateAtStart;\n\n    public UntilNode(ISourcePosition position, Node conditionNode, Node bodyNode) {\n        this(position, conditionNode, bodyNode, true);\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.UNTILNODE;\n    }\n\n    public UntilNode(ISourcePosition position, Node conditionNode, Node bodyNode, boolean evaluateAtStart) {\n        super(position, conditionNode.containsVariableAssignment() || bodyNode.containsVariableAssignment());\n        \n        assert conditionNode != null : \"conditionNode is not null\";\n        assert bodyNode != null : \"bodyNode is not null\";\n        \n        this.conditionNode = conditionNode;\n        this.bodyNode = bodyNode;\n        this.evaluateAtStart = evaluateAtStart;\n    }\n\n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitUntilNode(this);\n    }\n\n    /**\n     * Gets the bodyNode.\n     * @return Returns a Node\n     */\n    public Node getBodyNode() {\n        return bodyNode;\n    }\n\n    /**\n     * Gets the conditionNode.\n     * @return Returns a Node\n     */\n    public Node getConditionNode() {\n        return conditionNode;\n    }\n\n    public List<Node> childNodes() {\n        return Node.createList(conditionNode, bodyNode);\n    }\n    \n    /**\n     * Determine whether this is while or do while\n     * @return true if you are a while, false if do while\n     */\n    public boolean evaluateAtStart() {\n        return evaluateAtStart;\n    }\n}\n"
            }
        ],
        "SLOC": "97",
        "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2001-2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2001-2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/** \n * Represents a while statement. This could be the both versions:\n * \n * while &lt;condition&gt;\n *    &lt;body&gt;\n * end\n * \n * and\n * \n * &lt;body&gt; 'while' &lt;condition&gt;\n */\npublic class WhileNode extends Node {\n    private final Node conditionNode;\n    private final Node bodyNode;\n    private final boolean evaluateAtStart;\n    \n    public WhileNode(ISourcePosition position, Node conditionNode, Node bodyNode) {\n        this(position, conditionNode, bodyNode, true);\n    }\n\n    public WhileNode(ISourcePosition position, Node conditionNode, Node bodyNode,\n            boolean evalAtStart) {\n        super(position, conditionNode.containsVariableAssignment() || bodyNode.containsVariableAssignment());\n        \n        assert conditionNode != null : \"conditionNode is not null\";\n        assert bodyNode != null : \"bodyNode is not null\";\n        \n        this.conditionNode = conditionNode;\n        this.bodyNode = bodyNode;\n        this.evaluateAtStart = evalAtStart;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.WHILENODE;\n    }\n    \n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitWhileNode(this);\n    }\n    \n    /**\n     * Gets the bodyNode.\n     * @return Returns a Node\n     */\n    public Node getBodyNode() {\n        return bodyNode;\n    }\n\n    /**\n     * Gets the conditionNode.\n     * @return Returns a Node\n     */\n    public Node getConditionNode() {\n        return conditionNode;\n    }\n    \n    /**\n     * Determine whether this is while or do while\n     * @return true if you are a while, false if do while\n     */\n    public boolean evaluateAtStart() {\n        return evaluateAtStart;\n    }\n\n    public List<Node> childNodes() {\n        return Node.createList(conditionNode, bodyNode);\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ext/ffi/jffi/FastNumericMethodGenerator.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ext/ffi/jffi/FastLongMethodGenerator.java",
                "SLOC": "105",
                "content": "package org.jruby.ext.ffi.jffi;\n\n\nimport com.kenai.jffi.CallContext;\nimport com.kenai.jffi.CallingConvention;\nimport com.kenai.jffi.Platform;\nimport org.jruby.ext.ffi.NativeType;\n\n/**\n *\n */\nfinal class FastLongMethodGenerator extends AbstractNumericMethodGenerator {\n    private static final int MAX_PARAMETERS = getMaximumFastLongParameters();\n\n    private static final String[] signatures = buildSignatures(long.class, MAX_PARAMETERS);\n\n    private static final String[] methodNames = {\n        \"invokeL0\", \"invokeL1\", \"invokeL2\", \"invokeL3\", \"invokeL4\", \"invokeL5\", \"invokeL6\"\n    };\n\n    String getInvokerMethodName(JITSignature signature) {\n\n        final int parameterCount = signature.getParameterCount();\n\n        if (parameterCount <= MAX_PARAMETERS && parameterCount <= methodNames.length) {\n            return methodNames[parameterCount];\n\n        } else {\n            throw new IllegalArgumentException(\"invalid fast-long parameter count: \" + parameterCount);\n        }\n    }\n\n    String getInvokerSignature(int parameterCount) {\n        if (parameterCount <= MAX_PARAMETERS && parameterCount <= signatures.length) {\n            return signatures[parameterCount];\n        }\n        throw new IllegalArgumentException(\"invalid fast-long parameter count: \" + parameterCount);\n    }\n\n    final Class getInvokerIntType() {\n        return long.class;\n    }\n\n    public boolean isSupported(JITSignature signature) {\n        final int parameterCount = signature.getParameterCount();\n\n        if (!signature.getCallingConvention().equals(CallingConvention.DEFAULT) || parameterCount > MAX_PARAMETERS) {\n            return false;\n        }\n\n        final Platform platform = Platform.getPlatform();\n\n        if (platform.getOS().equals(Platform.OS.WINDOWS)) {\n            return false;\n        }\n\n        // Only supported on amd64 arches\n        if (!platform.getCPU().equals(Platform.CPU.X86_64)) {\n            return false;\n        }\n\n        for (int i = 0; i < parameterCount; i++) {\n            if (!isFastLongParameter(platform, signature.getParameterType(i))) {\n                return false;\n            }\n        }\n\n        return isFastLongResult(platform, signature.getResultType());\n    }\n\n\n    final static int getMaximumFastLongParameters() {\n        try {\n            com.kenai.jffi.Invoker.class.getDeclaredMethod(\"invokeL6\", CallContext.class, long.class,\n                    long.class, long.class, long.class, long.class, long.class, long.class);\n            return 6;\n        } catch (Throwable t) {\n            return -1;\n        }\n    }\n\n\n    private static boolean isFastLongType(Platform platform, NativeType type) {\n        switch (type) {\n            case BOOL:\n            case CHAR:\n            case UCHAR:\n            case SHORT:\n            case USHORT:\n            case INT:\n            case UINT:\n            case LONG:\n            case ULONG:\n            case LONG_LONG:\n            case ULONG_LONG:\n            case POINTER:\n                return true;\n\n            default:\n                return false;\n        }\n    }\n\n\n    static boolean isFastLongResult(Platform platform, NativeType type) {\n        switch (type) {\n            case VOID:\n                return true;\n                \n            case POINTER:\n            case STRING:\n            case TRANSIENT_STRING:\n                return platform.addressSize() == 64;\n\n            default:\n                return isFastLongType(platform, type);\n        }\n    }\n\n    static boolean isFastLongParameter(Platform platform, NativeType type) {\n        switch (type) {\n            case POINTER:\n            case BUFFER_IN:\n            case BUFFER_OUT:\n            case BUFFER_INOUT:\n            case STRING:\n            case TRANSIENT_STRING:\n                return platform.addressSize() == 64;\n            \n            default:\n                return isFastLongType(platform, type);\n        }\n    }\n}\n"
            }
        ],
        "SLOC": "105",
        "content": "package org.jruby.ext.ffi.jffi;\n\n\nimport com.kenai.jffi.CallContext;\nimport com.kenai.jffi.CallingConvention;\nimport com.kenai.jffi.Platform;\nimport org.jruby.ext.ffi.NativeType;\n\n/**\n *\n */\nfinal class FastNumericMethodGenerator extends AbstractNumericMethodGenerator {\n    private static final int MAX_PARAMETERS = getMaximumFastNumericParameters();\n\n    private static final String[] signatures = buildSignatures(long.class, MAX_PARAMETERS);\n\n    private static final String[] methodNames = {\n        \"invokeN0\", \"invokeN1\", \"invokeN2\", \"invokeN3\", \"invokeN4\", \"invokeN5\", \"invokeN6\"\n    };\n\n    String getInvokerMethodName(JITSignature signature) {\n\n        final int parameterCount = signature.getParameterCount();\n\n        if (parameterCount <= MAX_PARAMETERS && parameterCount <= methodNames.length) {\n            return methodNames[parameterCount];\n\n        } else {\n            throw new IllegalArgumentException(\"invalid fast-long parameter count: \" + parameterCount);\n        }\n    }\n\n    String getInvokerSignature(int parameterCount) {\n        if (parameterCount <= MAX_PARAMETERS && parameterCount <= signatures.length) {\n            return signatures[parameterCount];\n        }\n        throw new IllegalArgumentException(\"invalid fast-long parameter count: \" + parameterCount);\n    }\n\n    final Class getInvokerIntType() {\n        return long.class;\n    }\n\n    public boolean isSupported(JITSignature signature) {\n        final int parameterCount = signature.getParameterCount();\n\n        if (!signature.getCallingConvention().equals(CallingConvention.DEFAULT) || parameterCount > MAX_PARAMETERS) {\n            return false;\n        }\n\n        final Platform platform = Platform.getPlatform();\n\n        if (platform.getOS().equals(Platform.OS.WINDOWS)) {\n            return false;\n        }\n\n        // Only supported on amd64 arches\n        if (!platform.getCPU().equals(Platform.CPU.I386) && !platform.getCPU().equals(Platform.CPU.X86_64)) {\n            return false;\n        }\n\n        for (int i = 0; i < parameterCount; i++) {\n            if (!isFastNumericParameter(platform, signature.getParameterType(i))) {\n                return false;\n            }\n        }\n\n        return isFastNumericResult(platform, signature.getResultType());\n    }\n\n\n    final static int getMaximumFastNumericParameters() {\n        try {\n            com.kenai.jffi.Invoker.class.getDeclaredMethod(\"invokeN6\", CallContext.class, long.class,\n                    long.class, long.class, long.class, long.class, long.class, long.class);\n            return 6;\n        } catch (Throwable t) {\n            return -1;\n        }\n    }\n\n\n    private static boolean isFastNumericType(Platform platform, NativeType type) {\n        switch (type) {\n            case BOOL:\n            case CHAR:\n            case UCHAR:\n            case SHORT:\n            case USHORT:\n            case INT:\n            case UINT:\n            case LONG:\n            case ULONG:\n            case LONG_LONG:\n            case ULONG_LONG:\n            case FLOAT:\n            case DOUBLE:\n                return true;\n\n            default:\n                return false;\n        }\n    }\n\n\n    static boolean isFastNumericResult(Platform platform, NativeType type) {\n        switch (type) {\n            case VOID:\n            case POINTER:\n            case STRING:\n            case TRANSIENT_STRING:\n                return true;\n\n            default:\n                return isFastNumericType(platform, type);\n        }\n    }\n\n    static boolean isFastNumericParameter(Platform platform, NativeType type) {\n        switch (type) {\n            case POINTER:\n            case BUFFER_IN:\n            case BUFFER_OUT:\n            case BUFFER_INOUT:\n            case STRING:\n            case TRANSIENT_STRING:\n                return true;\n            \n            default:\n                return isFastNumericType(platform, type);\n        }\n    }\n}\n"
    }
}
Processed printing in 0:04:06.194141
