{
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/BTrueInstr.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/instructions/BFalseInstr.java",
                "SLOC": "32",
                "content": "package org.jruby.ir.instructions;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.operands.Label;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.persistence.IRReaderDecoder;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\nimport org.jruby.parser.StaticScope;\nimport org.jruby.runtime.DynamicScope;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\n\npublic class BFalseInstr extends OneOperandBranchInstr implements FixedArityInstr {\n    public BFalseInstr(Label jmpTarget, Operand v) {\n        super(Operation.B_FALSE, jmpTarget, v);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return new BFalseInstr(ii.getRenamedLabel(getJumpTarget()), getArg1().cloneForInlining(ii));\n    }\n\n    public static BFalseInstr decode(IRReaderDecoder d) {\n        return new BFalseInstr(d.decodeLabel(), d.decodeOperand());\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.BFalseInstr(this);\n    }\n\n    @Override\n    public int interpretAndGetNewIPC(ThreadContext context, DynamicScope currDynScope, StaticScope currScope, IRubyObject self, Object[] temp, int ipc) {\n        Object value1 = getArg1().retrieve(context, self, currScope, currDynScope, temp);\n        return !((IRubyObject)value1).isTrue() ? getJumpTarget().getTargetPC() : ipc;\n    }\n}\n"
            }
        ],
        "SLOC": "32",
        "content": "package org.jruby.ir.instructions;\n\nimport org.jruby.ir.IRVisitor;\nimport org.jruby.ir.Operation;\nimport org.jruby.ir.operands.Label;\nimport org.jruby.ir.operands.Operand;\nimport org.jruby.ir.persistence.IRReaderDecoder;\nimport org.jruby.ir.transformations.inlining.CloneInfo;\nimport org.jruby.parser.StaticScope;\nimport org.jruby.runtime.DynamicScope;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\n\npublic class BTrueInstr extends OneOperandBranchInstr implements FixedArityInstr {\n    public BTrueInstr(Label jmpTarget, Operand v) {\n        super(Operation.B_TRUE, jmpTarget, v);\n    }\n\n    @Override\n    public Instr clone(CloneInfo ii) {\n        return new BTrueInstr(ii.getRenamedLabel(getJumpTarget()), getArg1().cloneForInlining(ii));\n    }\n\n    public static BTrueInstr decode(IRReaderDecoder d) {\n        return new BTrueInstr(d.decodeLabel(), d.decodeOperand());\n    }\n\n    @Override\n    public void visit(IRVisitor visitor) {\n        visitor.BTrueInstr(this);\n    }\n\n    @Override\n    public int interpretAndGetNewIPC(ThreadContext context, DynamicScope currDynScope, StaticScope currScope, IRubyObject self, Object[] temp, int ipc) {\n        Object value1 = getArg1().retrieve(context, self, currScope, currDynScope, temp);\n        return ((IRubyObject)value1).isTrue() ? getJumpTarget().getTargetPC() : ipc;\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/targets/InstanceSuperInvokeSite.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ir/targets/ClassSuperInvokeSite.java",
                "SLOC": "33",
                "content": "package org.jruby.ir.targets;\n\nimport org.jruby.RubyClass;\nimport org.jruby.internal.runtime.methods.DynamicMethod;\nimport org.jruby.internal.runtime.methods.UndefinedMethod;\nimport org.jruby.ir.runtime.IRRuntimeHelpers;\nimport org.jruby.runtime.Block;\nimport org.jruby.runtime.CallType;\nimport org.jruby.runtime.Helpers;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport org.jruby.runtime.callsite.CacheEntry;\n\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodType;\nimport java.lang.invoke.SwitchPoint;\n\nimport static org.jruby.ir.runtime.IRRuntimeHelpers.splatArguments;\n\n/**\n* Created by headius on 10/23/14.\n*/\npublic class ClassSuperInvokeSite extends ResolvedSuperInvokeSite {\n    public ClassSuperInvokeSite(MethodType type, String name, String splatmapString, String file, int line) {\n        super(type, name, splatmapString, file, line);\n    }\n\n    @Override\n    protected RubyClass getSuperClass(RubyClass definingModule) {\n        return definingModule.getMetaClass().getMetaClass().getSuperClass();\n    }\n\n    // FIXME: indy cached version was not doing splat mapping; revert to slow logic for now\n\n    public IRubyObject invoke(ThreadContext context, IRubyObject caller, IRubyObject self, RubyClass definingModule, IRubyObject[] args, Block block) throws Throwable {\n        // TODO: get rid of caller\n        // TODO: caching\n        return IRRuntimeHelpers.classSuperSplatArgs(context, self, superName, definingModule, args, block, splatMap);\n    }\n}\n"
            }
        ],
        "SLOC": "34",
        "content": "package org.jruby.ir.targets;\n\nimport org.jruby.RubyClass;\nimport org.jruby.RubyModule;\nimport org.jruby.internal.runtime.methods.DynamicMethod;\nimport org.jruby.internal.runtime.methods.UndefinedMethod;\nimport org.jruby.ir.runtime.IRRuntimeHelpers;\nimport org.jruby.runtime.Block;\nimport org.jruby.runtime.CallType;\nimport org.jruby.runtime.Helpers;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport org.jruby.runtime.callsite.CacheEntry;\n\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodType;\nimport java.lang.invoke.SwitchPoint;\n\nimport static org.jruby.ir.runtime.IRRuntimeHelpers.splatArguments;\n\n/**\n* Created by headius on 10/23/14.\n*/\npublic class InstanceSuperInvokeSite extends ResolvedSuperInvokeSite {\n    public InstanceSuperInvokeSite(MethodType type, String name, String splatmapString, String file, int line) {\n        super(type, name, splatmapString, file, line);\n    }\n\n    @Override\n    protected RubyClass getSuperClass(RubyClass definingModule) {\n        return definingModule.getSuperClass();\n    }\n\n    // FIXME: indy cached version was not doing splat mapping; revert to slow logic for now\n\n    public IRubyObject invoke(ThreadContext context, IRubyObject caller, IRubyObject self, RubyClass definingModule, IRubyObject[] args, Block block) throws Throwable {\n        // TODO: get rid of caller\n        // TODO: caching\n        return IRRuntimeHelpers.instanceSuperSplatArgs(context, self, superName, definingModule, args, block, splatMap);\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/platform/UnixPlatform.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/platform/SolarisPlatform.java",
                "SLOC": "61",
                "content": "/***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2014 Timur Duehr <tduehr@gmail.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.platform;\n\nimport org.jruby.runtime.builtin.IRubyObject;\n\nimport java.lang.Class;\nimport java.lang.reflect.Method;\n\npublic class SolarisPlatform extends Platform {\n    private final Class systemClass;\n    private final Object system;\n    private final Method groupsMethod;\n\n    protected SolarisPlatform() {\n        Class sClass = null;\n        Object s = null;\n        Method g = null;\n        try {\n            sClass = Class.forName(\"com.sun.security.auth.module.SolarisSystem\");\n            s = sClass.getDeclaredConstructor().newInstance();\n            g = sClass.getDeclaredMethod(\"getGroups\");\n        } catch (Exception e) {\n            throw new UnsupportedOperationException(e.getMessage(), e);\n        }\n\n        systemClass = sClass;\n        system = s;\n        groupsMethod = g;\n    }\n\n    @Override\n    public long[] getGroups(IRubyObject recv) {\n        if (groupsMethod == null)\n            throw recv.getRuntime().newNotImplementedError(\"groups() function is unimplemented on this platform\");\n\n        try {\n            return (long[])groupsMethod.invoke(system);\n        } catch (Exception e) {\n            throw new UnsupportedOperationException(\"groups() function is unimplemented on this platform\", e);\n        }\n    }\n}\n"
            }
        ],
        "SLOC": "61",
        "content": "/***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2014 Timur Duehr <tduehr@gmail.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.platform;\n\nimport org.jruby.runtime.builtin.IRubyObject;\n\nimport java.lang.Class;\nimport java.lang.reflect.Method;\n\npublic class UnixPlatform extends Platform {\n    private final Class systemClass;\n    private final Object system;\n    private final Method groupsMethod;\n\n    protected UnixPlatform() {\n        Class sClass = null;\n        Object s = null;\n        Method g = null;\n        try {\n            sClass = Class.forName(\"com.sun.security.auth.module.UnixSystem\");\n            s = sClass.getDeclaredConstructor().newInstance();\n            g = sClass.getDeclaredMethod(\"getGroups\");\n        } catch (Exception e) {\n            throw new UnsupportedOperationException(e.getMessage(), e);\n        }\n\n        systemClass = sClass;\n        system = s;\n        groupsMethod = g;\n    }\n\n    @Override\n    public long[] getGroups(IRubyObject recv) {\n        if (groupsMethod == null)\n            throw recv.getRuntime().newNotImplementedError(\"groups() function is unimplemented on this platform\");\n\n        try {\n            return (long[])groupsMethod.invoke(system);\n        } catch (Exception e) {\n            throw new UnsupportedOperationException(\"groups() function is unimplemented on this platform\", e);\n        }\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/BitOrCallSite.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/BitAndCallSite.java",
                "SLOC": "50",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class BitAndCallSite extends MonomorphicCallSite {\n\n    public BitAndCallSite() {\n        super(\"&\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_and(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_and(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            }
        ],
        "SLOC": "50",
        "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class BitOrCallSite extends MonomorphicCallSite {\n\n    public BitOrCallSite() {\n        super(\"|\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_or(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_or(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/EqCallSite.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/CmpCallSite.java",
                "SLOC": "96",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class CmpCallSite extends BimorphicCallSite {\n\n    public CmpCallSite() {\n        super(\"<=>\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_cmp(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_cmp(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_cmp(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_cmp(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_cmp(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_cmp(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            }
        ],
        "SLOC": "96",
        "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class EqCallSite extends BimorphicCallSite {\n\n    public EqCallSite() {\n        super(\"==\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_equal(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_equal(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_equal(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_equal(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_equal(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_equal(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/GeCallSite.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/DivCallSite.java",
                "SLOC": "91",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class DivCallSite extends BimorphicCallSite {\n\n    public DivCallSite() {\n        super(\"/\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_div(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_div(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_div(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_div(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_div(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            }
        ],
        "SLOC": "91",
        "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class GeCallSite extends BimorphicCallSite {\n\n    public GeCallSite() {\n        super(\">=\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_ge(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_ge(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_ge(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_ge(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_ge(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n    \n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/GtCallSite.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/DivCallSite.java",
                "SLOC": "91",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class DivCallSite extends BimorphicCallSite {\n\n    public DivCallSite() {\n        super(\"/\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_div(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_div(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_div(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_div(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_div(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/GeCallSite.java",
                "SLOC": "91",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class GeCallSite extends BimorphicCallSite {\n\n    public GeCallSite() {\n        super(\">=\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_ge(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_ge(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_ge(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_ge(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_ge(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n    \n}\n"
            }
        ],
        "SLOC": "91",
        "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class GtCallSite extends BimorphicCallSite {\n\n    public GtCallSite() {\n        super(\">\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_gt(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_gt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_gt(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_gt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_gt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/LeCallSite.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/DivCallSite.java",
                "SLOC": "91",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class DivCallSite extends BimorphicCallSite {\n\n    public DivCallSite() {\n        super(\"/\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_div(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_div(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_div(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_div(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_div(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/GeCallSite.java",
                "SLOC": "91",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class GeCallSite extends BimorphicCallSite {\n\n    public GeCallSite() {\n        super(\">=\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_ge(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_ge(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_ge(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_ge(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_ge(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n    \n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/GtCallSite.java",
                "SLOC": "91",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class GtCallSite extends BimorphicCallSite {\n\n    public GtCallSite() {\n        super(\">\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_gt(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_gt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_gt(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_gt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_gt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            }
        ],
        "SLOC": "91",
        "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class LeCallSite extends BimorphicCallSite {\n\n    public LeCallSite() {\n        super(\"<=\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_le(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_le(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_le(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_le(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_le(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/LtCallSite.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/DivCallSite.java",
                "SLOC": "91",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class DivCallSite extends BimorphicCallSite {\n\n    public DivCallSite() {\n        super(\"/\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_div(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_div(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_div(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_div(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_div(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/GeCallSite.java",
                "SLOC": "91",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class GeCallSite extends BimorphicCallSite {\n\n    public GeCallSite() {\n        super(\">=\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_ge(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_ge(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_ge(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_ge(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_ge(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n    \n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/GtCallSite.java",
                "SLOC": "91",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class GtCallSite extends BimorphicCallSite {\n\n    public GtCallSite() {\n        super(\">\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_gt(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_gt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_gt(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_gt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_gt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/LeCallSite.java",
                "SLOC": "91",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class LeCallSite extends BimorphicCallSite {\n\n    public LeCallSite() {\n        super(\"<=\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_le(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_le(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_le(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_le(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_le(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            }
        ],
        "SLOC": "91",
        "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class LtCallSite extends BimorphicCallSite {\n\n    public LtCallSite() {\n        super(\"<\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_lt(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_lt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_lt(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_lt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_lt(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/MinusCallSite.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/CmpCallSite.java",
                "SLOC": "96",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class CmpCallSite extends BimorphicCallSite {\n\n    public CmpCallSite() {\n        super(\"<=>\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_cmp(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_cmp(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_cmp(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_cmp(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_cmp(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_cmp(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/EqCallSite.java",
                "SLOC": "96",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class EqCallSite extends BimorphicCallSite {\n\n    public EqCallSite() {\n        super(\"==\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_equal(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_equal(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_equal(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_equal(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_equal(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_equal(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            }
        ],
        "SLOC": "96",
        "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class MinusCallSite extends BimorphicCallSite {\n\n    public MinusCallSite() {\n        super(\"-\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_minus(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_minus(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_minus(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_minus(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_minus(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_minus(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/MulCallSite.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/CmpCallSite.java",
                "SLOC": "96",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class CmpCallSite extends BimorphicCallSite {\n\n    public CmpCallSite() {\n        super(\"<=>\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_cmp(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_cmp(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_cmp(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_cmp(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_cmp(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_cmp(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/EqCallSite.java",
                "SLOC": "96",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class EqCallSite extends BimorphicCallSite {\n\n    public EqCallSite() {\n        super(\"==\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_equal(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_equal(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_equal(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_equal(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_equal(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_equal(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/MinusCallSite.java",
                "SLOC": "96",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class MinusCallSite extends BimorphicCallSite {\n\n    public MinusCallSite() {\n        super(\"-\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_minus(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_minus(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_minus(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_minus(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_minus(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_minus(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            }
        ],
        "SLOC": "96",
        "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class MulCallSite extends BimorphicCallSite {\n\n    public MulCallSite() {\n        super(\"*\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_mul(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_mul(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_mul(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_mul(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_mul(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_mul(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/PlusCallSite.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/CmpCallSite.java",
                "SLOC": "96",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class CmpCallSite extends BimorphicCallSite {\n\n    public CmpCallSite() {\n        super(\"<=>\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_cmp(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_cmp(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_cmp(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_cmp(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_cmp(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_cmp(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/EqCallSite.java",
                "SLOC": "96",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class EqCallSite extends BimorphicCallSite {\n\n    public EqCallSite() {\n        super(\"==\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_equal(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_equal(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_equal(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_equal(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_equal(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_equal(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/MinusCallSite.java",
                "SLOC": "96",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class MinusCallSite extends BimorphicCallSite {\n\n    public MinusCallSite() {\n        super(\"-\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_minus(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_minus(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_minus(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_minus(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_minus(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_minus(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/MulCallSite.java",
                "SLOC": "96",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class MulCallSite extends BimorphicCallSite {\n\n    public MulCallSite() {\n        super(\"*\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_mul(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_mul(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_mul(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_mul(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_mul(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_mul(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            }
        ],
        "SLOC": "96",
        "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyFloat;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class PlusCallSite extends BimorphicCallSite {\n\n    public PlusCallSite() {\n        super(\"+\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_plus(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_plus(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_plus(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_plus(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, double arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_plus(context, arg1);\n            }\n        } else if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache instanceof FloatEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFloat) self).op_plus(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    protected CacheEntry setSecondaryCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFloat && entry.method.isBuiltin()) {\n            return secondaryCache = new FloatEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return secondaryCache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    @Override\n    public boolean isSecondaryBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFloat) {\n            CacheEntry cache = this.secondaryCache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FloatEntry;\n        }\n        return super.isSecondaryBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n    private static class FloatEntry extends CacheEntry {\n\n        FloatEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/ShiftLeftCallSite.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/BitAndCallSite.java",
                "SLOC": "50",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class BitAndCallSite extends MonomorphicCallSite {\n\n    public BitAndCallSite() {\n        super(\"&\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_and(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_and(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/BitOrCallSite.java",
                "SLOC": "50",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class BitOrCallSite extends MonomorphicCallSite {\n\n    public BitOrCallSite() {\n        super(\"|\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_or(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_or(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            }
        ],
        "SLOC": "50",
        "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class ShiftLeftCallSite extends MonomorphicCallSite {\n    public ShiftLeftCallSite() {\n        super(\"<<\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_lshift(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_lshift(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/ShiftRightCallSite.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/BitAndCallSite.java",
                "SLOC": "50",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class BitAndCallSite extends MonomorphicCallSite {\n\n    public BitAndCallSite() {\n        super(\"&\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_and(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_and(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/BitOrCallSite.java",
                "SLOC": "50",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class BitOrCallSite extends MonomorphicCallSite {\n\n    public BitOrCallSite() {\n        super(\"|\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_or(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_or(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/ShiftLeftCallSite.java",
                "SLOC": "50",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class ShiftLeftCallSite extends MonomorphicCallSite {\n    public ShiftLeftCallSite() {\n        super(\"<<\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_lshift(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_lshift(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            }
        ],
        "SLOC": "50",
        "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class ShiftRightCallSite extends MonomorphicCallSite {\n\n    public ShiftRightCallSite() {\n        super(\">>\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_rshift(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_rshift(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/XorCallSite.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/BitAndCallSite.java",
                "SLOC": "50",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class BitAndCallSite extends MonomorphicCallSite {\n\n    public BitAndCallSite() {\n        super(\"&\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_and(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_and(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/BitOrCallSite.java",
                "SLOC": "50",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class BitOrCallSite extends MonomorphicCallSite {\n\n    public BitOrCallSite() {\n        super(\"|\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_or(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_or(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/ShiftLeftCallSite.java",
                "SLOC": "50",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class ShiftLeftCallSite extends MonomorphicCallSite {\n    public ShiftLeftCallSite() {\n        super(\"<<\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_lshift(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_lshift(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/callsite/ShiftRightCallSite.java",
                "SLOC": "50",
                "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class ShiftRightCallSite extends MonomorphicCallSite {\n\n    public ShiftRightCallSite() {\n        super(\">>\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_rshift(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_rshift(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
            }
        ],
        "SLOC": "50",
        "content": "package org.jruby.runtime.callsite;\n\nimport org.jruby.RubyFixnum;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport static org.jruby.RubyBasicObject.getMetaClass;\n\npublic class XorCallSite extends MonomorphicCallSite {\n    public XorCallSite() {\n        super(\"^\");\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, long arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_xor(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    public IRubyObject call(ThreadContext context, IRubyObject caller, IRubyObject self, IRubyObject arg1) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache instanceof FixnumEntry && cache.typeOk(getMetaClass(self))) {\n                return ((RubyFixnum) self).op_xor(context, arg1);\n            }\n        }\n        return super.call(context, caller, self, arg1);\n    }\n\n    @Override\n    protected CacheEntry setCache(final CacheEntry entry, final IRubyObject self) {\n        if (self instanceof RubyFixnum && entry.method.isBuiltin()) {\n            return cache = new FixnumEntry(entry); // tagged entry - do isBuiltin check once\n        }\n        return cache = entry;\n    }\n\n    @Override\n    public boolean isBuiltin(final IRubyObject self) {\n        if (self instanceof RubyFixnum) {\n            CacheEntry cache = this.cache;\n            if (cache.typeOk(getMetaClass(self))) return cache instanceof FixnumEntry;\n        }\n        return super.isBuiltin(self);\n    }\n\n    private static class FixnumEntry extends CacheEntry {\n\n        FixnumEntry(CacheEntry entry) {\n            super(entry.method, entry.sourceModule, entry.token);\n        }\n\n    }\n\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/ivars/StampedVariableAccessor.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/runtime/ivars/NonvolatileVariableAccessor.java",
                "SLOC": "144",
                "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.runtime.ivars;\n\nimport org.jruby.RubyBasicObject;\nimport org.jruby.RubyClass;\nimport org.jruby.util.ArraySupport;\nimport org.jruby.util.unsafe.UnsafeHolder;\n\n/**\n * A VariableAccessor that directly updates instance variables without an explicit memory fence\n * or synchronization.\n *\n * If the table itself must be created for the first time or grown to accommodate a new variable,\n * those operations will be done in a thread-safe (volatile, atomic) way. However updates of an\n * entry in an existing table will not have any explicit memory fence or synchronization.\n */\npublic class NonvolatileVariableAccessor extends VariableAccessor {\n    /**\n     * Construct a new NonvolatileVariableAccessor for the given \"real\" class,\n     * variable name, variable index, and class ID.\n     *\n     * @param realClass the \"real\" class\n     * @param name the variable's name\n     * @param index the variable's index\n     * @param classId the class's ID\n     */\n    public NonvolatileVariableAccessor(RubyClass realClass, String name, int index, int classId) {\n        super(realClass, name, index, classId);\n    }\n\n    /**\n     * Set this variable into the given object using Unsafe to ensure\n     * safe creation or growth of the variable table.\n     *\n     * @param object the object into which to set this variable\n     * @param value the variable's value\n     */\n    public void set(Object object, Object value) {\n        ((RubyBasicObject) object).ensureInstanceVariablesSettable();\n        setVariable((RubyBasicObject) object, realClass, index, value);\n    }\n\n    /**\n     * Set the given variable index into the specified object. The \"real\" class\n     * and index are pass in to provide functional access. This version checks\n     * if self has been frozen before proceeding to set the variable.\n     *\n     * @param self the object into which to set the variable\n     * @param realClass the \"real\" class for the object\n     * @param index the index of the variable\n     * @param value the variable's value\n     */\n    public static void setVariableChecked(RubyBasicObject self, RubyClass realClass, int index, Object value) {\n        self.ensureInstanceVariablesSettable();\n        setVariable(self, realClass, index, value);\n    }\n\n    /**\n     * Set the given variable index into the specified object. The \"real\" class\n     * and index are pass in to provide functional access.\n     *\n     * @param self the object into which to set the variable\n     * @param realClass the \"real\" class for the object\n     * @param index the index of the variable\n     * @param value the variable's value\n     */\n    public static void setVariable(RubyBasicObject self, RubyClass realClass, int index, Object value) {\n        while (true) {\n            int currentStamp = self.varTableStamp;\n            // spin-wait if odd\n            if((currentStamp & 0x01) != 0)\n                continue;\n\n            Object[] currentTable = (Object[]) UnsafeHolder.U.getObjectVolatile(self, RubyBasicObject.VAR_TABLE_OFFSET);\n\n            if (currentTable == null || index >= currentTable.length) {\n                if (!createTableUnsafe(self, currentStamp, realClass, currentTable, index, value)) continue;\n            } else {\n                if (!updateTable(self, currentStamp, currentTable, index, value)) continue;\n            }\n\n            break;\n        }\n    }\n\n    /**\n     * Create or exapand a table for the given object, using Unsafe CAS and\n     * ordering operations to ensure visibility.\n     *\n     * @param self the object into which to set the variable\n     * @param currentStamp the current variable table stamp\n     * @param realClass the \"real\" class for the object\n     * @param currentTable the current table\n     * @param index the index of the variable\n     * @param value the variable's value\n     * @return whether the update was successful, for CAS retrying\n     */\n    private static boolean createTableUnsafe(RubyBasicObject self, int currentStamp, RubyClass realClass, Object[] currentTable, int index, Object value) {\n        // try to acquire exclusive access to the varTable field\n        if (!UnsafeHolder.U.compareAndSwapInt(self, RubyBasicObject.STAMP_OFFSET, currentStamp, ++currentStamp)) {\n            return false;\n        }\n\n        Object[] newTable = new Object[realClass.getVariableTableSizeWithExtras()];\n\n        if (currentTable != null) {\n            ArraySupport.copy(currentTable, 0, newTable, 0, currentTable.length);\n        }\n\n        newTable[index] = value;\n\n        UnsafeHolder.U.putOrderedObject(self, RubyBasicObject.VAR_TABLE_OFFSET, newTable);\n\n        // release exclusive access\n        self.varTableStamp = currentStamp + 1;\n\n        return true;\n    }\n\n    /**\n     * Update the given table table directly.\n     *\n     * @param self the object into which to set the variable\n     * @param currentStamp the current variable table stamp\n     * @param currentTable the current table\n     * @param index the index of the variable\n     * @param value the variable's value\n     * @return whether the update was successful, for CAS retrying\n     */\n    private static boolean updateTable(RubyBasicObject self, int currentStamp, Object[] currentTable, int index, Object value) {\n        currentTable[index] = value;\n\n        // validate stamp. redo on concurrent modification\n        return self.varTableStamp == currentStamp;\n    }\n}\n"
            }
        ],
        "SLOC": "143",
        "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.runtime.ivars;\n\nimport org.jruby.RubyBasicObject;\nimport org.jruby.RubyClass;\nimport org.jruby.util.ArraySupport;\nimport org.jruby.util.unsafe.UnsafeHolder;\n\n/**\n * A variable accessor that uses a stamped volatile int and Unsafe methods to\n * ensure thread-friendly table updating.\n */\npublic class StampedVariableAccessor extends VariableAccessor {\n    /**\n     * Construct a new StampedVariableAccessor for the given \"real\" class,\n     * variable name, variable index, and class ID.\n     * \n     * @param realClass the \"real\" class\n     * @param name the variable's name\n     * @param index the variable's index\n     * @param classId the class's ID\n     */\n    public StampedVariableAccessor(RubyClass realClass, String name, int index, int classId) {\n        super(realClass, name, index, classId);\n    }\n\n    /**\n     * Set this variable into the given object using Unsafe to ensure\n     * safe updating of the variable table.\n     * \n     * @param object the object into which to set this variable\n     * @param value the variable's value\n     */\n    public void set(Object object, Object value) {\n        ((RubyBasicObject)object).ensureInstanceVariablesSettable();\n        setVariable((RubyBasicObject)object, realClass, index, value);\n    }\n    \n    /**\n     * Set the given variable index into the specified object. The \"real\" class\n     * and index are pass in to provide functional access. This version checks\n     * if self has been frozen before proceeding to set the variable.\n     * \n     * @param self the object into which to set the variable\n     * @param realClass the \"real\" class for the object\n     * @param index the index of the variable\n     * @param value the variable's value\n     */\n    public static void setVariableChecked(RubyBasicObject self, RubyClass realClass, int index, Object value) {\n        self.ensureInstanceVariablesSettable();\n        setVariable(self, realClass, index, value);\n    }\n    \n    /**\n     * Set the given variable index into the specified object. The \"real\" class\n     * and index are pass in to provide functional access.\n     * \n     * @param self the object into which to set the variable\n     * @param realClass the \"real\" class for the object\n     * @param index the index of the variable\n     * @param value the variable's value\n     */\n    public static void setVariable(RubyBasicObject self, RubyClass realClass, int index, Object value) {\n        while (true) {\n            int currentStamp = self.varTableStamp;\n            // spin-wait if odd\n            if((currentStamp & 0x01) != 0)\n               continue;\n            \n            Object[] currentTable = (Object[]) UnsafeHolder.U.getObjectVolatile(self, RubyBasicObject.VAR_TABLE_OFFSET);\n            \n            if (currentTable == null || index >= currentTable.length) {\n                if (!createTableUnsafe(self, currentStamp, realClass, currentTable, index, value)) continue;\n            } else {\n                if (!updateTableUnsafe(self, currentStamp, currentTable, index, value)) continue;\n            }\n            \n            break;\n        }\n    }\n\n    /**\n     * Create or exapand a table for the given object, using Unsafe CAS and\n     * ordering operations to ensure visibility.\n     * \n     * @param self the object into which to set the variable\n     * @param currentStamp the current variable table stamp\n     * @param realClass the \"real\" class for the object\n     * @param currentTable the current table\n     * @param index the index of the variable\n     * @param value the variable's value\n     * @return whether the update was successful, for CAS retrying\n     */\n    private static boolean createTableUnsafe(RubyBasicObject self, int currentStamp, RubyClass realClass, Object[] currentTable, int index, Object value) {\n        // try to acquire exclusive access to the varTable field\n        if (!UnsafeHolder.U.compareAndSwapInt(self, RubyBasicObject.STAMP_OFFSET, currentStamp, ++currentStamp)) {\n            return false;\n        }\n        \n        Object[] newTable = new Object[realClass.getVariableTableSizeWithExtras()];\n        \n        if (currentTable != null) {\n            ArraySupport.copy(currentTable, 0, newTable, 0, currentTable.length);\n        }\n        \n        newTable[index] = value;\n        \n        UnsafeHolder.U.putOrderedObject(self, RubyBasicObject.VAR_TABLE_OFFSET, newTable);\n        \n        // release exclusive access\n        self.varTableStamp = currentStamp + 1;\n        \n        return true;\n    }\n\n    /**\n     * Update the given table table for the given object, using Unsafe fence or\n     * volatile operations to ensure visibility.\n     * \n     * @param self the object into which to set the variable\n     * @param currentStamp the current variable table stamp\n     * @param currentTable the current table\n     * @param index the index of the variable\n     * @param value the variable's value\n     * @return whether the update was successful, for CAS retrying\n     */\n    private static boolean updateTableUnsafe(RubyBasicObject self, int currentStamp, Object[] currentTable, int index, Object value) {\n        // shared access to varTable field.\n        currentTable[index] = value;\n        UnsafeHolder.U.fullFence();\n\n        // validate stamp. redo on concurrent modification\n        return self.varTableStamp == currentStamp;\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/maven/jruby/src/it/extended/src/test/java/org/example/BaseTest.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/maven/jruby-jars/src/it/extended/src/test/java/org/example/BaseTest.java",
                "SLOC": "77",
                "content": "package org.example;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.Arrays;\nimport java.io.File;\nimport java.io.StringWriter;\n\nimport org.jruby.embed.LocalContextScope;\nimport org.jruby.embed.ScriptingContainer;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class BaseTest {\n\n    private final String basedir = new File( System.getProperty(\"basedir\"), \"../../../../../\" ).getAbsolutePath();\n\n    private ScriptingContainer newScriptingContainer() {\n        ScriptingContainer container = new ScriptingContainer(LocalContextScope.SINGLETHREAD);\n        container.setCurrentDirectory(basedir);\n    \tcontainer.getProvider().getRubyInstanceConfig().setLoadPaths(Arrays.asList(\".\", \"test\", \"test/mri\", \"test/mri/ruby\"));\n        container.runScriptlet(\"ENV['GEM_PATH']='lib/ruby/gems/shared'\");\n        return container;\n    }\n\n    private void runTests(ScriptingContainer container) throws Exception {\n        container.getProvider().getRuntime().tearDown(true);\n        container.terminate();\n    }\n\n    private void collectTests(ScriptingContainer container, String index) throws Exception {\n        container.runScriptlet(\"File.open(File.join('test', '\" + index + \".index')) do |f|\\n\" +\n                               \"      f.each_line.each do |line|\\n\" +\n                               \"        next if line =~ /^#/ or line.strip.empty?\\n\" +\n                               \"        filename = \\\"test/mri/#{line.chomp}\\\"\\n\" +\n                               \"        filename = \\\"test/jruby/#{line.chomp}.rb\\\" unless File.exist? filename\\n\" +\n                               \"        filename = \\\"test/#{line.chomp}.rb\\\" unless File.exist? filename\\n\" +\n                               \"        next unless File.file? filename\\n\" +\n                               \"        next if filename =~ /mri\\\\/net\\\\/http\\\\//\\n\" +\n                               \"        next if filename =~ /mri\\\\/ruby\\\\/test_class/\\n\" +\n                               \"        next if filename =~ /mri\\\\/ruby\\\\/test_io/\\n\" +\n                               \"        next if filename =~ /mri\\\\/ruby\\\\/test_econv/\\n\" +\n                               // TODO find a way to obey the minitest/excludes and get those back\n                               \"        next if filename =~ /psych\\\\/test_encoding.rb/\\n\" +\n                               \"        next if filename =~ /psych\\\\/test_parser.rb/\\n\" +\n                               \"        next if filename =~ /psych\\\\/test_psych.rb/\\n\" +\n                               \"        next if filename =~ /psych\\\\/visitors\\\\/test_yaml_tree.rb/\\n\" +\n                               \"        next if filename =~ /psych\\\\/test_document.rb/\\n\" +\n                               \"        next if filename =~ /psych\\\\/test_tree_builder.rb/\\n\" +\n                               \"        next if filename =~ /psych\\\\/test_date_time.rb/\\n\" +\n                               \"        next if filename =~ /psych\\\\/test_nil.rb/\\n\" +\n                               // TODO file an issue or so\n                               \"        next if filename =~ /test_load_compiled_ruby.rb/\\n\" +\n                               \"        next if filename =~ /compiler\\\\/test_jrubyc.rb/\\n\" +\n                               // TODO remove the following after fix of #2215\n                               \"        next if filename =~ /test_jar_on_load_path.rb/\\n\" +\n                               \"        next if filename =~ /test_file.rb/\\n\" +\n                               \"        filename.sub!( /.*\\\\/test\\\\//, 'test/' )\\n\" +\n                               \"        puts filename\\n\" +\n                               \"        require filename\\n\" +\n                               \"      end\\n\" +\n                               \"    end\");\n    }\n\n    void runIt(String index) throws Exception {\n        runIt(index, null);\n    }\n\n    void runIt(String index, String script) throws Exception {\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n        try {\n            //Thread.currentThread().setContextClassLoader();\n            System.err.println(\"\\n\\nrunning --------- \" + index + \"\\n\");\n            ScriptingContainer container = newScriptingContainer();\n            if (script != null) container.runScriptlet( script );\n            if (index != null) collectTests(container, index);\n            runTests(container);\n        }\n        finally {\n            Thread.currentThread().setContextClassLoader(cl);\n        }\n    }\n\n    // @Test\n    // public void test() throws Exception {\n    // \trunIt(null, \"require '/home/christian/projects/active/maven/jruby/test/jruby/test_command_line_switches.rb'\");\n    // }\n\n}\n"
            }
        ],
        "SLOC": "76",
        "content": "package org.example;\n\nimport java.util.Arrays;\nimport java.io.File;\nimport java.net.URL;\nimport java.net.URLClassLoader;\n\nimport org.jruby.embed.LocalContextScope;\nimport org.jruby.embed.ScriptingContainer;\n\npublic class BaseTest {\n\n    private final String basedir = new File( System.getProperty(\"basedir\"), \"../../../../../\" ).getAbsolutePath();\n\n    private ScriptingContainer newScriptingContainer() {\n        ScriptingContainer container = new ScriptingContainer(LocalContextScope.SINGLETHREAD);\n        container.setCurrentDirectory(basedir);\n    \tcontainer.getProvider().getRubyInstanceConfig().setLoadPaths(Arrays.asList(\".\", \"test\", \"test/mri\", \"test/mri/ruby\"));\n        container.runScriptlet(\"ENV['GEM_PATH']='lib/ruby/gems/shared'\");\n        return container;\n    }\n\n    private void runTests(ScriptingContainer container) throws Exception {\n        container.getProvider().getRuntime().tearDown(true);\n        container.terminate();\n    }\n\n    protected void collectTests(ScriptingContainer container, String index) throws Exception {\n        container.runScriptlet(\n            \"File.open(File.join('test', '\" + index + \".index')) do |f|\\n\" +\n            \"      f.each_line do |line|\\n\" +\n            \"        next if line =~ /^#/ or line.strip.empty?\\n\" +\n            \"        filename = \\\"test/mri/#{line.chomp}\\\"\\n\" +\n            \"        filename = \\\"test/jruby/#{line.chomp}.rb\\\" unless File.exist? filename\\n\" +\n            \"        filename = \\\"test/#{line.chomp}.rb\\\" unless File.exist? filename\\n\" +\n            \"        next unless File.file? filename\\n\" +\n            \"        next if filename =~ /mri\\\\/net\\\\/http\\\\//\\n\" +\n            \"        next if filename =~ /mri\\\\/ruby\\\\/test_class/\\n\" +\n            \"        next if filename =~ /mri\\\\/ruby\\\\/test_io/\\n\" +\n            \"        next if filename =~ /mri\\\\/ruby\\\\/test_econv/\\n\" +\n            // TODO find a way to obey the minitest/excludes and get those back\n            \"        next if filename =~ /psych\\\\/test_encoding.rb/\\n\" +\n            \"        next if filename =~ /psych\\\\/test_parser.rb/\\n\" +\n            \"        next if filename =~ /psych\\\\/test_psych.rb/\\n\" +\n            \"        next if filename =~ /psych\\\\/visitors\\\\/test_yaml_tree.rb/\\n\" +\n            \"        next if filename =~ /psych\\\\/test_document.rb/\\n\" +\n            \"        next if filename =~ /psych\\\\/test_tree_builder.rb/\\n\" +\n            \"        next if filename =~ /psych\\\\/test_date_time.rb/\\n\" +\n            \"        next if filename =~ /psych\\\\/test_nil.rb/\\n\" +\n            // TODO file an issue or so\n            \"        next if filename =~ /test_load_compiled_ruby.rb/\\n\" +\n            \"        next if filename =~ /compiler\\\\/test_jrubyc.rb/\\n\" +\n            // TODO remove the following after fix of #2215\n            \"        next if filename =~ /test_jar_on_load_path.rb/\\n\" +\n            \"        next if filename =~ /test_file.rb/\\n\" +\n            \"        filename.sub!( /.*\\\\/test\\\\//, 'test/' )\\n\" +\n            \"        puts filename\\n\" +\n            \"        require filename\\n\" +\n            \"      end\\n\" +\n            \"    end\" );\n    }\n\n    void runIt(String index) throws Exception {\n        runIt(index, null);\n    }\n\n    void runIt(String index, String script) throws Exception {\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n        try {\n            Thread.currentThread().setContextClassLoader(new URLClassLoader( new URL[] {}, null ));\n            System.err.println(\"\\n\\nrunning --------- \" + index + \"\\n\");\n            ScriptingContainer container = newScriptingContainer();\n            if (script != null) container.runScriptlet( script );\n            if (index != null) collectTests(container, index);\n            runTests(container);\n        }\n        finally {\n            Thread.currentThread().setContextClassLoader(cl);\n        }\n    }\n\n    // @Test\n    // public void test() throws Exception {\n    // \trunIt(null, \"require '/home/christian/projects/active/maven/jruby/test/jruby/test_command_line_switches.rb'\");\n    // }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/GlobalAsgnNode.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/ClassVarAsgnNode.java",
                "SLOC": "75",
                "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.RubySymbol;\nimport org.jruby.ast.types.INameNode;\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/**\n * Class variable assignment node.\n */\npublic class ClassVarAsgnNode extends AssignableNode implements INameNode {\n    private RubySymbol name;\n\n    /**\n     * @param name id of the class variable to assign to\n     * @param valueNode  Node used to compute the new value when the assignment is evaled\n     */\n    public ClassVarAsgnNode(ISourcePosition position, RubySymbol name, Node valueNode) {\n        super(position, valueNode, valueNode != null && valueNode.containsVariableAssignment());\n        \n        this.name = name;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.CLASSVARASGNNODE;\n    }\n\n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitClassVarAsgnNode(this);\n    }\n\n    /**\n     * Gets the name.\n     * @return Returns a String\n     */\n    public RubySymbol getName() {\n        return name;\n    }\n\n    public List<Node> childNodes() {\n        return createList(getValueNode());\n    }\n\n    @Override\n    public boolean needsDefinitionCheck() {\n        return false;\n    }\n}\n"
            }
        ],
        "SLOC": "74",
        "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2004 Charles O Nutter <headius@headius.com>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * Copyright (C) 2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2004 Stefan Matthias Aust <sma@3plus4.de>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.RubySymbol;\nimport org.jruby.ast.types.INameNode;\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/**\n * Represents an assignment to a global variable.\n */\npublic class GlobalAsgnNode extends AssignableNode implements INameNode {\n    private RubySymbol name;\n\n    public GlobalAsgnNode(ISourcePosition position, RubySymbol name, Node valueNode) {\n        super(position, valueNode, valueNode != null && valueNode.containsVariableAssignment());\n\n        this.name = name;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.GLOBALASGNNODE;\n    }\n    \n    /**\n     * RubyMethod used by visitors.\n     * accepts the visitor \n     * @param iVisitor the visitor to accept\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitGlobalAsgnNode(this);\n    }\n    /**\n     * Gets the name.\n     * @return Returns a String\n     */\n    public RubySymbol getName() {\n        return name;\n    }\n    \n    public List<Node> childNodes() {\n        return createList(getValueNode());\n    }\n\n    @Override\n    public boolean needsDefinitionCheck() {\n        return false;\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/GlobalVarNode.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/ClassVarNode.java",
                "SLOC": "67",
                "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2002 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.RubySymbol;\nimport org.jruby.ast.types.INameNode;\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/**\n * Access to a class variable.\n */\npublic class ClassVarNode extends Node implements INameNode, SideEffectFree {\n    private RubySymbol name;\n\n    public ClassVarNode(ISourcePosition position, RubySymbol name) {\n        super(position, false);\n        this.name = name;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.CLASSVARNODE;\n    }\n\n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitClassVarNode(this);\n    }\n\n    /**\n     * Gets the name.\n     * @return Returns a String\n     */\n    public RubySymbol getName() {\n        return name;\n    }\n    \n    public List<Node> childNodes() {\n        return EMPTY_LIST;\n    }\n}\n"
            }
        ],
        "SLOC": "67",
        "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2002 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.RubySymbol;\nimport org.jruby.ast.types.INameNode;\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/**\n *\taccess to a global variable.\n */\npublic class GlobalVarNode extends Node implements INameNode, SideEffectFree {\n    private RubySymbol name;\n\n    public GlobalVarNode(ISourcePosition position, RubySymbol name) {\n        super(position, false);\n        this.name = name;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.GLOBALVARNODE;\n    }\n    \n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitGlobalVarNode(this);\n    }\n\n    /**\n     * Gets the name.\n     * @return Returns a String\n     */\n    public RubySymbol getName() {\n        return name;\n    }\n\n    public List<Node> childNodes() {\n        return EMPTY_LIST;\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/InstVarNode.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/ClassVarNode.java",
                "SLOC": "67",
                "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2002 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.RubySymbol;\nimport org.jruby.ast.types.INameNode;\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/**\n * Access to a class variable.\n */\npublic class ClassVarNode extends Node implements INameNode, SideEffectFree {\n    private RubySymbol name;\n\n    public ClassVarNode(ISourcePosition position, RubySymbol name) {\n        super(position, false);\n        this.name = name;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.CLASSVARNODE;\n    }\n\n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitClassVarNode(this);\n    }\n\n    /**\n     * Gets the name.\n     * @return Returns a String\n     */\n    public RubySymbol getName() {\n        return name;\n    }\n    \n    public List<Node> childNodes() {\n        return EMPTY_LIST;\n    }\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/GlobalVarNode.java",
                "SLOC": "67",
                "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2002 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.RubySymbol;\nimport org.jruby.ast.types.INameNode;\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/**\n *\taccess to a global variable.\n */\npublic class GlobalVarNode extends Node implements INameNode, SideEffectFree {\n    private RubySymbol name;\n\n    public GlobalVarNode(ISourcePosition position, RubySymbol name) {\n        super(position, false);\n        this.name = name;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.GLOBALVARNODE;\n    }\n    \n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitGlobalVarNode(this);\n    }\n\n    /**\n     * Gets the name.\n     * @return Returns a String\n     */\n    public RubySymbol getName() {\n        return name;\n    }\n\n    public List<Node> childNodes() {\n        return EMPTY_LIST;\n    }\n}\n"
            }
        ],
        "SLOC": "68",
        "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2002 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * Copyright (C) 2006 Lukas Felber <lfelber@hsr.ch>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.RubySymbol;\nimport org.jruby.ast.types.INameNode;\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/** \n * Represents an instance variable accessor.\n */\npublic class InstVarNode extends Node implements INameNode, SideEffectFree {\n    private RubySymbol name;\n\n    public InstVarNode(ISourcePosition position, RubySymbol name) {\n        super(position, false);\n        this.name = name;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.INSTVARNODE;\n    }\n    \n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitInstVarNode(this);\n    }\n\t\n    /**\n     * Gets the name.\n     * @return Returns a String\n     */\n    public RubySymbol getName() {\n        return name;\n    }\n\n    public List<Node> childNodes() {\n        return EMPTY_LIST;\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/LocalAsgnNode.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/DAsgnNode.java",
                "SLOC": "93",
                "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2001-2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2001-2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2004-2006 Thomas E Enebo <enebo@acm.org>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.RubySymbol;\nimport org.jruby.ast.types.INameNode;\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/**\n * An assignment to a dynamic variable (e.g. block scope local variable).\n */\npublic class DAsgnNode extends AssignableNode implements INameNode, IScopedNode {\n    // The name of the variable\n    private RubySymbol name;\n    \n    // A scoped location of this variable (high 16 bits is how many scopes down and low 16 bits\n    // is what index in the right scope to set the value.\n    private int location;\n\n    public DAsgnNode(ISourcePosition position, RubySymbol name, int location, Node valueNode) {\n        super(position, valueNode, true);\n        this.name = name;\n        this.location = location;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.DASGNNODE;\n    }\n    \n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitDAsgnNode(this);\n    }\n    \n    /**\n     * Gets the name.\n     * @return Returns a String\n     */\n    public RubySymbol getName() {\n        return name;\n    }\n\n    /**\n     * How many scopes should we burrow down to until we need to set the block variable value.\n     * \n     * @return 0 for current scope, 1 for one down, ...\n     */\n    public int getDepth() {\n        return location >> 16;\n    }\n    \n    /**\n     * Gets the index within the scope construct that actually holds the eval'd value\n     * of this local variable\n     * \n     * @return Returns an int offset into storage structure\n     */\n    public int getIndex() {\n        return location & 0xffff;\n    }\n    \n    public List<Node> childNodes() {\n        return createList(getValueNode());\n    }\n\n    @Override\n    public boolean needsDefinitionCheck() {\n        return false;\n    }\n}\n"
            }
        ],
        "SLOC": "93",
        "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * Copyright (C) 2004 Stefan Matthias Aust <sma@3plus4.de>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.RubySymbol;\nimport org.jruby.ast.types.INameNode;\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/**\n * An assignment to a local variable.\n */\npublic class LocalAsgnNode extends AssignableNode implements INameNode, IScopedNode {\n    // The name of the variable\n    private RubySymbol name;\n    \n    // A scoped location of this variable (high 16 bits is how many scopes down and low 16 bits\n    // is what index in the right scope to set the value.\n    private final int location;\n\n    public LocalAsgnNode(ISourcePosition position, RubySymbol name, int location, Node valueNode) {\n        super(position, valueNode, true);\n        this.name = name;\n        this.location = location;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.LOCALASGNNODE;\n    }\n    \n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitLocalAsgnNode(this);\n    }\n    \n    /**\n     * Name of the local assignment.\n     **/\n    public RubySymbol getName() {\n        return name;\n    }\n\n    /**\n     * How many scopes should we burrow down to until we need to set the block variable value.\n     * \n     * @return 0 for current scope, 1 for one down, ...\n     */\n    public int getDepth() {\n        return location >> 16;\n    }\n    \n    /**\n     * Gets the index within the scope construct that actually holds the eval'd value\n     * of this local variable\n     * \n     * @return Returns an int offset into storage structure\n     */\n    public int getIndex() {\n        return location & 0xffff;\n    }\n    \n    public List<Node> childNodes() {\n        return createList(getValueNode());\n    }\n\n    @Override\n    public boolean needsDefinitionCheck() {\n        return false;\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/LocalVarNode.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/DVarNode.java",
                "SLOC": "93",
                "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2001-2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2001-2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2002 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2004-2006 Thomas E Enebo <enebo@acm.org>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.RubySymbol;\nimport org.jruby.ast.types.INameNode;\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/**\n * Access a dynamic variable (e.g. block scope local variable).\n */\npublic class DVarNode extends Node implements INameNode, IScopedNode, SideEffectFree {\n    // The name of the variable\n    private RubySymbol name;\n    \n    // A scoped location of this variable (high 16 bits is how many scopes down and low 16 bits\n    // is what index in the right scope to set the value.\n    private int location;\n\n    public DVarNode(ISourcePosition position, int location, RubySymbol name) {\n        super(position, false);\n        this.location = location;\n        this.name = name;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.DVARNODE;\n    }\n    \n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitDVarNode(this);\n    }\n    \n    /**\n     * How many scopes should we burrow down to until we need to set the block variable value.\n     * \n     * @return 0 for current scope, 1 for one down, ...\n     */\n    public int getDepth() {\n        return location >> 16;\n    }\n    \n    /**\n     * Gets the index within the scope construct that actually holds the eval'd value\n     * of this local variable\n     * \n     * @return Returns an int offset into storage structure\n     */\n    public int getIndex() {\n        return location & 0xffff;\n    }\n\n    /**\n     * Gets the name.\n     * @return Returns a String\n     */\n    public RubySymbol getName() {\n        return name;\n    }\n    \n    public List<Node> childNodes() {\n        return EMPTY_LIST;\n    }\n\n    @Override\n    public boolean needsDefinitionCheck() {\n        return false;\n    }\n}\n"
            }
        ],
        "SLOC": "94",
        "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2002 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2004-2006 Thomas E Enebo <enebo@acm.org>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.RubySymbol;\nimport org.jruby.ast.types.INameNode;\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/**\n * Access a local variable \n */\npublic class LocalVarNode extends Node implements INameNode, IScopedNode, SideEffectFree {\n    // The name of the variable\n    private RubySymbol name;\n    \n    // A scoped location of this variable (high 16 bits is how many scopes down and low 16 bits\n    // is what index in the right scope to set the value.\n    private final int location;\n\n    public LocalVarNode(ISourcePosition position, int location, RubySymbol name) {\n        super(position, false);\n        this.location = location;\n        this.name = name;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.LOCALVARNODE;\n    }\n\n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitLocalVarNode(this);\n    }\n\n    /**\n     * How many scopes should we burrow down to until we need to set the block variable value.\n     * \n     * @return 0 for current scope, 1 for one down, ...\n     */\n    public int getDepth() {\n        return location >> 16;\n    }\n    \n    /**\n     * Gets the index within the scope construct that actually holds the eval'd value\n     * of this local variable\n     * \n     * @return Returns an int offset into storage structure\n     */\n    public int getIndex() {\n        return location & 0xffff;\n    }\n\n    /**\n     * What is the name of this variable\n     * \n     * @return the name of the variable\n     */\n    public RubySymbol getName() {\n        return name;\n    }\n    \n    public List<Node> childNodes() {\n        return EMPTY_LIST;\n    }\n\n    @Override\n    public boolean needsDefinitionCheck() {\n        return false;\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/Match3Node.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/Match2Node.java",
                "SLOC": "77",
                "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2001-2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2001-2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\npublic class Match2Node extends Node {\n    private final Node receiverNode;\n    private final Node valueNode;\n\n    public Match2Node(ISourcePosition position, Node receiverNode, Node valueNode) {\n        super(position, receiverNode.containsVariableAssignment() || valueNode.containsVariableAssignment());\n        \n        assert receiverNode != null : \"receiverNode is not null\";\n        assert valueNode != null : \"valueNode is not null\";\n\n        this.receiverNode = receiverNode;\n        this.valueNode = valueNode;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.MATCH2NODE;\n    }\n\n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitMatch2Node(this);\n    }\n\n    /**\n     * Gets the receiverNode.\n     * @return Returns a Node\n     */\n    public Node getReceiverNode() {\n        return receiverNode;\n    }\n\n    /**\n     * Gets the valueNode.\n     * @return Returns a Node\n     */\n    public Node getValueNode() {\n        return valueNode;\n    }\n    \n    public List<Node> childNodes() {\n        return Node.createList(receiverNode, valueNode);\n    }\n\n    @Override\n    public boolean needsDefinitionCheck() {\n        return false;\n    }\n}\n"
            }
        ],
        "SLOC": "80",
        "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2001-2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2001-2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/**\n * Used when a Regexp literal is the RHS of a match call.  E.g., \"abc\" =~ /.+/\n */\npublic class Match3Node extends Node {\n    private final Node receiverNode;\n    private final Node valueNode;\n\n    public Match3Node(ISourcePosition position, Node receiverNode, Node valueNode) {\n        super(position, receiverNode.containsVariableAssignment() || valueNode.containsVariableAssignment());\n        \n        assert receiverNode != null : \"receiverNode is not null\";\n        assert valueNode != null : \"valueNode is not null\";\n\n        this.receiverNode = receiverNode;\n        this.valueNode = valueNode;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.MATCH3NODE;\n    }\n\n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitMatch3Node(this);\n    }\n\n    /**\n     * Gets the receiverNode.\n     * @return Returns a Node\n     */\n    public Node getReceiverNode() {\n        return receiverNode;\n    }\n\n    /**\n     * Gets the valueNode.\n     * @return Returns a Node\n     */\n    public Node getValueNode() {\n        return valueNode;\n    }\n    \n    public List<Node> childNodes() {\n        return Node.createList(receiverNode, valueNode);\n    }\n\n    @Override\n    public boolean needsDefinitionCheck() {\n        return false;\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/OpAsgnOrNode.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/OpAsgnAndNode.java",
                "SLOC": "73",
                "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2001-2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2001-2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2002 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\npublic class OpAsgnAndNode extends Node implements BinaryOperatorNode {\n    private final Node firstNode;\n    private final Node secondNode;\n\n    public OpAsgnAndNode(ISourcePosition position, Node headNode, Node valueNode) {\n        super(position, headNode.containsVariableAssignment() || valueNode.containsVariableAssignment());\n        \n        assert headNode != null : \"headNode is not null\";\n        assert valueNode != null : \"valueNode is not null\";\n        \n        firstNode = headNode;\n        secondNode = valueNode;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.OPASGNANDNODE;\n    }\n\n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitOpAsgnAndNode(this);\n    }\n\n    /**\n     * Gets the firstNode.\n     * @return Returns a Node\n     */\n    public Node getFirstNode() {\n        return firstNode;\n    }\n\n    /**\n     * Gets the secondNode.\n     * @return Returns a Node\n     */\n    public Node getSecondNode() {\n        return secondNode;\n    }\n\n    public List<Node> childNodes() {\n        return Node.createList(firstNode, secondNode);\n    }\n}\n"
            }
        ],
        "SLOC": "73",
        "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2001-2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2001-2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2002-2004 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\npublic class OpAsgnOrNode extends Node implements BinaryOperatorNode {\n    private final Node firstNode;\n    private final Node secondNode;\n\n    public OpAsgnOrNode(ISourcePosition position, Node headNode, Node valueNode) {\n        super(position, headNode.containsVariableAssignment() || valueNode.containsVariableAssignment());\n        \n        assert headNode != null : \"headNode is not null\";\n        assert valueNode != null : \"valueNode is not null\";\n        \n        firstNode = headNode;\n        secondNode = valueNode;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.OPASGNORNODE;\n    }\n\n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitOpAsgnOrNode(this);\n    }\n\n    /**\n     * Gets the firstNode.\n     * @return Returns a Node\n     */\n    public Node getFirstNode() {\n        return firstNode;\n    }\n\n    /**\n     * Gets the secondNode.\n     * @return Returns a Node\n     */\n    public Node getSecondNode() {\n        return secondNode;\n    }\n    \n    public List<Node> childNodes() {\n        return Node.createList(firstNode, secondNode);\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/ReturnNode.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/NextNode.java",
                "SLOC": "69",
                "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2001-2002 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2001-2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2002 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/** \n * Represents a 'next' statement.\n */\npublic class NextNode extends Node implements NonLocalControlFlowNode {\n    private final Node valueNode;\n\n    public NextNode(ISourcePosition position, Node valueNode) {\n        super(position, valueNode.containsVariableAssignment());\n        \n        assert valueNode != null : \"valueNode is not null\";\n        \n        this.valueNode = valueNode;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.NEXTNODE;\n    }\n    \n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitNextNode(this);\n    }\n    \n    /**\n     * Gets the valueNode.\n     * @return Returns a Node\n     */\n    public Node getValueNode() {\n        return valueNode;\n    }\n\n    public boolean hasValue() {\n        return valueNode != NilImplicitNode.NIL;\n    }\n    \n    public List<Node> childNodes() {\n        return createList(valueNode);\n    }\n}\n"
            }
        ],
        "SLOC": "65",
        "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2001-2002 Benoit Cerrina <b.cerrina@wanadoo.fr>\n * Copyright (C) 2001-2004 Jan Arne Petersen <jpetersen@uni-bonn.de>\n * Copyright (C) 2002 Anders Bengtsson <ndrsbngtssn@yahoo.se>\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\n/** \n * Represents a return statement.\n */\npublic class ReturnNode extends Node implements NonLocalControlFlowNode {\n    private final Node valueNode;\n\n    public ReturnNode(ISourcePosition position, Node valueNode) {\n        super(position, valueNode.containsVariableAssignment());\n        \n        assert valueNode != null : \"valueNode is not null\";\n        \n        this.valueNode = valueNode;\n    }\n\n    public NodeType getNodeType() {\n        return NodeType.RETURNNODE;\n    }\n\n    /**\n     * Accept for the visitor pattern.\n     * @param iVisitor the visitor\n     **/\n    public <T> T accept(NodeVisitor<T> iVisitor) {\n        return iVisitor.visitReturnNode(this);\n    }\n\n    public Node getValueNode() {\n        return valueNode;\n    }\n\n    public boolean hasValue() {\n        return valueNode != NilImplicitNode.NIL;\n    }\n    \n    public List<Node> childNodes() {\n        return createList(valueNode);\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/SplatNode.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ast/SValueNode.java",
                "SLOC": "56",
                "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * Copyright (C) 2004 Stefan Matthias Aust <sma@3plus4.de>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\npublic class SValueNode extends Node {\n    protected final Node node;\n\n    public SValueNode(ISourcePosition position, Node node) {\n        super(position, node.containsVariableAssignment());\n\n        assert node != null : \"node is not null\";\n\n        this.node = node;\n    }\n\n    @Override\n    public NodeType getNodeType() {\n        return NodeType.SVALUENODE;\n    }\n\n    @Override\n    public <T> T accept(NodeVisitor<T> visitor) {\n        return visitor.visitSValueNode(this);\n    }\n\n    public Node getValue() {\n        return node;\n    }\n\n    @Override\n    public List<Node> childNodes() {\n        return createList(node);\n    }\n}\n"
            }
        ],
        "SLOC": "56",
        "content": "/*\n ***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2004 Thomas E Enebo <enebo@acm.org>\n * Copyright (C) 2004 Stefan Matthias Aust <sma@3plus4.de>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ast;\n\nimport java.util.List;\n\nimport org.jruby.ast.visitor.NodeVisitor;\nimport org.jruby.lexer.yacc.ISourcePosition;\n\npublic class SplatNode extends Node {\n    protected final Node node;\n\n    public SplatNode(ISourcePosition position, Node node) {\n        super(position, node.containsVariableAssignment());\n\n        assert node != null : \"node is not null\";\n\n        this.node = node;\n    }\n\n    @Override\n    public NodeType getNodeType() {\n        return NodeType.SPLATNODE;\n    }\n\n    @Override\n    public <T> T accept(NodeVisitor<T> visitor) {\n        return visitor.visitSplatNode(this);\n    }\n\n    public Node getValue() {\n        return node;\n    }\n\n    @Override\n    public List<Node> childNodes() {\n        return createList(node);\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ext/digest/MD5.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ext/digest/DigestLibrary.java",
                "SLOC": "39",
                "content": "/***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2006 Ola Bini <ola@ologix.com>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ext.digest;\n\nimport java.io.IOException;\n\nimport org.jruby.Ruby;\nimport org.jruby.runtime.load.Library;\n\n/**\n * @author <a href=\"mailto:ola.bini@ki.se\">Ola Bini</a>\n */\npublic class DigestLibrary implements Library {\n    public void load(final Ruby runtime, boolean wrap) throws IOException {\n        org.jruby.ext.digest.RubyDigest.createDigest(runtime);\n    }\n}// DigestLibrary\n"
            }
        ],
        "SLOC": "37",
        "content": "/*\n **** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2010 Charles Oliver Nutter <headius@headius.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ext.digest;\n\nimport java.io.IOException;\nimport org.jruby.Ruby;\nimport org.jruby.runtime.load.Library;\n\npublic class MD5 implements Library {\n\n    public void load(final Ruby runtime, boolean wrap) throws IOException {\n        org.jruby.ext.digest.RubyDigest.createDigestMD5(runtime);\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ext/digest/RMD160.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ext/digest/DigestLibrary.java",
                "SLOC": "39",
                "content": "/***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2006 Ola Bini <ola@ologix.com>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ext.digest;\n\nimport java.io.IOException;\n\nimport org.jruby.Ruby;\nimport org.jruby.runtime.load.Library;\n\n/**\n * @author <a href=\"mailto:ola.bini@ki.se\">Ola Bini</a>\n */\npublic class DigestLibrary implements Library {\n    public void load(final Ruby runtime, boolean wrap) throws IOException {\n        org.jruby.ext.digest.RubyDigest.createDigest(runtime);\n    }\n}// DigestLibrary\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ext/digest/MD5.java",
                "SLOC": "37",
                "content": "/*\n **** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2010 Charles Oliver Nutter <headius@headius.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ext.digest;\n\nimport java.io.IOException;\nimport org.jruby.Ruby;\nimport org.jruby.runtime.load.Library;\n\npublic class MD5 implements Library {\n\n    public void load(final Ruby runtime, boolean wrap) throws IOException {\n        org.jruby.ext.digest.RubyDigest.createDigestMD5(runtime);\n    }\n}\n"
            }
        ],
        "SLOC": "37",
        "content": "/*\n **** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2010 Charles Oliver Nutter <headius@headius.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ext.digest;\n\nimport java.io.IOException;\nimport org.jruby.Ruby;\nimport org.jruby.runtime.load.Library;\n\npublic class RMD160 implements Library {\n\n    public void load(final Ruby runtime, boolean wrap) throws IOException {\n        org.jruby.ext.digest.RubyDigest.createDigestRMD160(runtime);\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ext/digest/SHA1.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ext/digest/DigestLibrary.java",
                "SLOC": "39",
                "content": "/***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2006 Ola Bini <ola@ologix.com>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ext.digest;\n\nimport java.io.IOException;\n\nimport org.jruby.Ruby;\nimport org.jruby.runtime.load.Library;\n\n/**\n * @author <a href=\"mailto:ola.bini@ki.se\">Ola Bini</a>\n */\npublic class DigestLibrary implements Library {\n    public void load(final Ruby runtime, boolean wrap) throws IOException {\n        org.jruby.ext.digest.RubyDigest.createDigest(runtime);\n    }\n}// DigestLibrary\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ext/digest/MD5.java",
                "SLOC": "37",
                "content": "/*\n **** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2010 Charles Oliver Nutter <headius@headius.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ext.digest;\n\nimport java.io.IOException;\nimport org.jruby.Ruby;\nimport org.jruby.runtime.load.Library;\n\npublic class MD5 implements Library {\n\n    public void load(final Ruby runtime, boolean wrap) throws IOException {\n        org.jruby.ext.digest.RubyDigest.createDigestMD5(runtime);\n    }\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ext/digest/RMD160.java",
                "SLOC": "37",
                "content": "/*\n **** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2010 Charles Oliver Nutter <headius@headius.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ext.digest;\n\nimport java.io.IOException;\nimport org.jruby.Ruby;\nimport org.jruby.runtime.load.Library;\n\npublic class RMD160 implements Library {\n\n    public void load(final Ruby runtime, boolean wrap) throws IOException {\n        org.jruby.ext.digest.RubyDigest.createDigestRMD160(runtime);\n    }\n}\n"
            }
        ],
        "SLOC": "37",
        "content": "/*\n **** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2010 Charles Oliver Nutter <headius@headius.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ext.digest;\n\nimport java.io.IOException;\nimport org.jruby.Ruby;\nimport org.jruby.runtime.load.Library;\n\npublic class SHA1 implements Library {\n\n    public void load(final Ruby runtime, boolean wrap) throws IOException {\n        org.jruby.ext.digest.RubyDigest.createDigestSHA1(runtime);\n    }\n}\n"
    },
    "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ext/digest/SHA2.java": {
        "clones": [
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ext/digest/DigestLibrary.java",
                "SLOC": "39",
                "content": "/***** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2006 Ola Bini <ola@ologix.com>\n * \n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ext.digest;\n\nimport java.io.IOException;\n\nimport org.jruby.Ruby;\nimport org.jruby.runtime.load.Library;\n\n/**\n * @author <a href=\"mailto:ola.bini@ki.se\">Ola Bini</a>\n */\npublic class DigestLibrary implements Library {\n    public void load(final Ruby runtime, boolean wrap) throws IOException {\n        org.jruby.ext.digest.RubyDigest.createDigest(runtime);\n    }\n}// DigestLibrary\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ext/digest/MD5.java",
                "SLOC": "37",
                "content": "/*\n **** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2010 Charles Oliver Nutter <headius@headius.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ext.digest;\n\nimport java.io.IOException;\nimport org.jruby.Ruby;\nimport org.jruby.runtime.load.Library;\n\npublic class MD5 implements Library {\n\n    public void load(final Ruby runtime, boolean wrap) throws IOException {\n        org.jruby.ext.digest.RubyDigest.createDigestMD5(runtime);\n    }\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ext/digest/RMD160.java",
                "SLOC": "37",
                "content": "/*\n **** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2010 Charles Oliver Nutter <headius@headius.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ext.digest;\n\nimport java.io.IOException;\nimport org.jruby.Ruby;\nimport org.jruby.runtime.load.Library;\n\npublic class RMD160 implements Library {\n\n    public void load(final Ruby runtime, boolean wrap) throws IOException {\n        org.jruby.ext.digest.RubyDigest.createDigestRMD160(runtime);\n    }\n}\n"
            },
            {
                "file": "/home/kilgore/Documents/git/SourcererCC/sysc5105-project/jruby-dist-9.2.13.0-src.zip/jruby-9.2.13.0/core/src/main/java/org/jruby/ext/digest/SHA1.java",
                "SLOC": "37",
                "content": "/*\n **** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2010 Charles Oliver Nutter <headius@headius.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ext.digest;\n\nimport java.io.IOException;\nimport org.jruby.Ruby;\nimport org.jruby.runtime.load.Library;\n\npublic class SHA1 implements Library {\n\n    public void load(final Ruby runtime, boolean wrap) throws IOException {\n        org.jruby.ext.digest.RubyDigest.createDigestSHA1(runtime);\n    }\n}\n"
            }
        ],
        "SLOC": "37",
        "content": "/*\n **** BEGIN LICENSE BLOCK *****\n * Version: EPL 2.0/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Eclipse Public\n * License Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.eclipse.org/legal/epl-v20.html\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * Copyright (C) 2010 Charles Oliver Nutter <headius@headius.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either of the GNU General Public License Version 2 or later (the \"GPL\"),\n * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the EPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the EPL, the GPL or the LGPL.\n ***** END LICENSE BLOCK *****/\n\npackage org.jruby.ext.digest;\n\nimport java.io.IOException;\nimport org.jruby.Ruby;\nimport org.jruby.runtime.load.Library;\n\npublic class SHA2 implements Library {\n\n    public void load(final Ruby runtime, boolean wrap) throws IOException {\n        org.jruby.ext.digest.RubyDigest.createDigestSHA2(runtime);\n    }\n}\n"
    },
    "sysc5105-project/vlc-master/tree/master/modules/gui/macosx/views/VLCHUDTableView.h": {
        "clones": [
            {
                "file": "sysc5105-project/vlc-master/tree/master/modules/gui/macosx/views/VLCHUDOutlineView.h",
                "SLOC": "45",
                "content": "//\n//  VLCHUDOutlineView.h\n//  BGHUDAppKit\n//\n//  Created by BinaryGod on 6/20/08.\n//\n//  Copyright (c) 2008, Tim Davis (BinaryMethod.com, binary.god@gmail.com)\n//  All rights reserved.\n//\n//  Redistribution and use in source and binary forms, with or without modification,\n//  are permitted provided that the following conditions are met:\n//\n//\t\tRedistributions of source code must retain the above copyright notice, this\n//\tlist of conditions and the following disclaimer.\n//\n//\t\tRedistributions in binary form must reproduce the above copyright notice,\n//\tthis list of conditions and the following disclaimer in the documentation and/or\n//\tother materials provided with the distribution.\n//\n//\t\tNeither the name of the BinaryMethod.com nor the names of its contributors\n//\tmay be used to endorse or promote products derived from this software without\n//\tspecific prior written permission.\n//\n//\tTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND\n//\tANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n//\tWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n//\tIN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n//\tINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n//\tBUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n//\tOR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n//\tWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n//\tARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n//\tPOSSIBILITY OF SUCH DAMAGE.\n\n#import <Cocoa/Cocoa.h>\n\n@interface VLCHUDOutlineView : NSOutlineView\n\n@property (strong) NSColor *tableBackgroundColor;\n@property (strong) NSArray *cellAlternatingRowColors;\n@property (strong) NSColor *cellHighlightColor;\n@property (strong) NSColor *cellEditingFillColor;\n@property (strong) NSColor *cellTextColor;\n@property (strong) NSColor *cellSelectedTextColor;\n@property (strong) NSColor *strokeColor;\n\n@property (strong) NSGradient *highlightGradient;\n@property (strong) NSGradient *normalGradient;\n\n@end\n"
            }
        ],
        "SLOC": "45",
        "content": "//\n//  VLCHUDTableView.h\n//  BGHUDAppKit\n//\n//  Created by BinaryGod on 6/17/08.\n//\n//  Copyright (c) 2008, Tim Davis (BinaryMethod.com, binary.god@gmail.com)\n//  All rights reserved.\n//\n//  Redistribution and use in source and binary forms, with or without modification,\n//  are permitted provided that the following conditions are met:\n//\n//\t\tRedistributions of source code must retain the above copyright notice, this\n//\tlist of conditions and the following disclaimer.\n//\n//\t\tRedistributions in binary form must reproduce the above copyright notice,\n//\tthis list of conditions and the following disclaimer in the documentation and/or\n//\tother materials provided with the distribution.\n//\n//\t\tNeither the name of the BinaryMethod.com nor the names of its contributors\n//\tmay be used to endorse or promote products derived from this software without\n//\tspecific prior written permission.\n//\n//\tTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND\n//\tANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n//\tWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n//\tIN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n//\tINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n//\tBUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n//\tOR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n//\tWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n//\tARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n//\tPOSSIBILITY OF SUCH DAMAGE.\n\n#import <Cocoa/Cocoa.h>\n\n@interface VLCHUDTableView : NSTableView\n\n@property (strong) NSColor *tableBackgroundColor;\n@property (strong) NSArray *cellAlternatingRowColors;\n@property (strong) NSColor *cellHighlightColor;\n@property (strong) NSColor *cellEditingFillColor;\n@property (strong) NSColor *cellTextColor;\n@property (strong) NSColor *cellSelectedTextColor;\n@property (strong) NSColor *strokeColor;\n\n@property (strong) NSGradient *highlightGradient;\n@property (strong) NSGradient *normalGradient;\n\n@end\n"
    }
}
Processed printing in 0:03:56.018850
